---
title: gRPC
description: Узнайте о gRPC, ее роли в собственных приложениях в облаке и о том, как она отличается от обмена данными с RESTFUL по протоколу HTTP.
author: robvet
no-loc:
- Blazor
- Blazor WebAssembly
ms.date: 05/13/2020
ms.openlocfilehash: 4a0c88472d2b19efb2ff0f58395003b1b6409131
ms.sourcegitcommit: ef50c99928183a0bba75e07b9f22895cd4c480f8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2020
ms.locfileid: "87914896"
---
# <a name="grpc"></a><span data-ttu-id="49ae6-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="49ae6-103">gRPC</span></span>

<span data-ttu-id="49ae6-104">До сих пор в этой книге мы сосредоточены на связи на [основе RESTful](https://docs.microsoft.com/azure/architecture/best-practices/api-design) .</span><span class="sxs-lookup"><span data-stu-id="49ae6-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="49ae6-105">Мы увидели, что остальное является гибким архитектурным стилем, который определяет операции на основе CRUD на ресурсах сущностей.</span><span class="sxs-lookup"><span data-stu-id="49ae6-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="49ae6-106">Клиенты взаимодействуют с ресурсами по протоколу HTTP с помощью модели связи "запрос-ответ".</span><span class="sxs-lookup"><span data-stu-id="49ae6-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="49ae6-107">Несмотря на широкое внедрение технологии RESTFUL, более новая технология связи, gRPC, получила огромный опыт работы сообщества в облаке.</span><span class="sxs-lookup"><span data-stu-id="49ae6-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="49ae6-108">Что такое gRPC?</span><span class="sxs-lookup"><span data-stu-id="49ae6-108">What is gRPC?</span></span>

<span data-ttu-id="49ae6-109">gRPC — это современная высокопроизводительная платформа, которая используется для развития устаревшего протокола [удаленного вызова процедур (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) .</span><span class="sxs-lookup"><span data-stu-id="49ae6-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="49ae6-110">На уровне приложения gRPC упрощает обмен сообщениями между клиентами и серверными службами.</span><span class="sxs-lookup"><span data-stu-id="49ae6-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="49ae6-111">Исходя из Google, gRPC является открытым исходным кодом и частью экосистемы [облачных вычислений (кнкф)](https://www.cncf.io/) облачных собственных предложений.</span><span class="sxs-lookup"><span data-stu-id="49ae6-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="49ae6-112">КНКФ считает gRPC [проект инкубация](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span><span class="sxs-lookup"><span data-stu-id="49ae6-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="49ae6-113">Инкубация означает, что конечные пользователи используют технологию в рабочих приложениях, а проект имеет работоспособное количество участников.</span><span class="sxs-lookup"><span data-stu-id="49ae6-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="49ae6-114">Типичное клиентское приложение gRPC будет предоставлять локальную, внутрипроцессный функцию, которая реализует бизнес-операцию.</span><span class="sxs-lookup"><span data-stu-id="49ae6-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="49ae6-115">На самом деле локальная функция вызывает другую функцию на удаленном компьютере.</span><span class="sxs-lookup"><span data-stu-id="49ae6-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="49ae6-116">То, что кажется локальным вызовом, по сути становится прозрачным необработанным вызовом к удаленной службе.</span><span class="sxs-lookup"><span data-stu-id="49ae6-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="49ae6-117">Механизм RPC абстрагирует сетевую связь «точка-точка», сериализацию и выполнение между компьютерами.</span><span class="sxs-lookup"><span data-stu-id="49ae6-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="49ae6-118">В собственных облачных приложениях разработчики часто работают на языках программирования, платформах и технологиях.</span><span class="sxs-lookup"><span data-stu-id="49ae6-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="49ae6-119">Такое *взаимодействие* усложняет контракты сообщений и коммуникации, необходимых для межплатформенного обмена данными.</span><span class="sxs-lookup"><span data-stu-id="49ae6-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="49ae6-120">gRPC предоставляет «равномерный горизонтальный слой», который абстрагирует эти проблемы.</span><span class="sxs-lookup"><span data-stu-id="49ae6-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="49ae6-121">Разработчики в своей собственной платформе получают код для бизнес-функций, тогда как gRPC обрабатывает коммуникационные коммуникации.</span><span class="sxs-lookup"><span data-stu-id="49ae6-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="49ae6-122">gRPC предлагает комплексную поддержку для большинства популярных стеков разработки, включая Java, JavaScript, C#, Go, SWIFT и NodeJS.</span><span class="sxs-lookup"><span data-stu-id="49ae6-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="49ae6-123">Преимущества gRPC</span><span class="sxs-lookup"><span data-stu-id="49ae6-123">gRPC Benefits</span></span>

<span data-ttu-id="49ae6-124">gRPC использует HTTP/2 для транспортного протокола.</span><span class="sxs-lookup"><span data-stu-id="49ae6-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="49ae6-125">Несмотря на то, что совместимость с HTTP 1,1, HTTP/2 включает в себя множество дополнительных возможностей:</span><span class="sxs-lookup"><span data-stu-id="49ae6-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="49ae6-126">Протокол двоичной кадрирования для транспорта данных, в отличие от HTTP 1,1, который основан на тексте.</span><span class="sxs-lookup"><span data-stu-id="49ae6-126">A binary framing protocol for data transport - unlike HTTP 1.1, which is text based.</span></span>
- <span data-ttu-id="49ae6-127">Поддержка мультиплексирования для отправки нескольких параллельных запросов через одно подключение — HTTP 1,1 ограничивает обработку одного сообщения "запрос-ответ" за раз.</span><span class="sxs-lookup"><span data-stu-id="49ae6-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="49ae6-128">Двунаправленный дуплексный обмен данными для одновременной отправки клиентских запросов и ответов сервера.</span><span class="sxs-lookup"><span data-stu-id="49ae6-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="49ae6-129">Встроенная потоковая передача, позволяющая запросам и ответам асинхронного потока больших наборов данных.</span><span class="sxs-lookup"><span data-stu-id="49ae6-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>
- <span data-ttu-id="49ae6-130">Сжатие заголовков, уменьшающее использование сети.</span><span class="sxs-lookup"><span data-stu-id="49ae6-130">Header compression that reduces network usage.</span></span>

<span data-ttu-id="49ae6-131">gRPC является упрощенной и очень производительной.</span><span class="sxs-lookup"><span data-stu-id="49ae6-131">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="49ae6-132">Это может быть не более 8X, чем сериализация JSON с сообщениями 60-80% меньше.</span><span class="sxs-lookup"><span data-stu-id="49ae6-132">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="49ae6-133">В Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) терминах производительность gRPC превышает скорость и эффективность [привязок NetTcp](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)с высоким уровнем оптимизации.</span><span class="sxs-lookup"><span data-stu-id="49ae6-133">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="49ae6-134">В отличие от NetTCP, которая предпочитает стек Майкрософт, gRPC является кросс-платформенным.</span><span class="sxs-lookup"><span data-stu-id="49ae6-134">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="49ae6-135">Protocol Buffers</span><span class="sxs-lookup"><span data-stu-id="49ae6-135">Protocol Buffers</span></span>

<span data-ttu-id="49ae6-136">gRPC использует технологию с открытым исходным кодом, называемую [буферами протоколов](https://developers.google.com/protocol-buffers/docs/overview).</span><span class="sxs-lookup"><span data-stu-id="49ae6-136">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="49ae6-137">Они предоставляют очень эффективный и независимый от платформы формат сериализации для сериализации структурированных сообщений, которые службы отправляют друг другу.</span><span class="sxs-lookup"><span data-stu-id="49ae6-137">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="49ae6-138">Используя язык IDL, разработчики определяют контракт службы для каждой микрослужбы.</span><span class="sxs-lookup"><span data-stu-id="49ae6-138">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="49ae6-139">Контракт, реализованный в виде текстового `.proto` файла, описывает методы, входные и выходные данные для каждой службы.</span><span class="sxs-lookup"><span data-stu-id="49ae6-139">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="49ae6-140">Один и тот же файл контракта можно использовать для клиентов и служб gRPC, созданных на разных платформах разработки.</span><span class="sxs-lookup"><span data-stu-id="49ae6-140">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="49ae6-141">Используя файл с таким же параметром, компилятор protobuf `protoc` создает как клиентский, так и код службы для целевой платформы.</span><span class="sxs-lookup"><span data-stu-id="49ae6-141">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="49ae6-142">Код включает следующие компоненты:</span><span class="sxs-lookup"><span data-stu-id="49ae6-142">The code includes the following components:</span></span>

- <span data-ttu-id="49ae6-143">Строго типизированные объекты, совместно используемые клиентом и службой, которые представляют операции службы и элементы данных для сообщения.</span><span class="sxs-lookup"><span data-stu-id="49ae6-143">Strongly typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="49ae6-144">Строго типизированный базовый класс с необходимыми сетевыми механизмами, которые может наследовать и расширять служба удаленной gRPC.</span><span class="sxs-lookup"><span data-stu-id="49ae6-144">A strongly typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="49ae6-145">Клиентская заглушка, которая содержит необходимые коммуникации для вызова удаленной службы gRPC.</span><span class="sxs-lookup"><span data-stu-id="49ae6-145">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="49ae6-146">Во время выполнения каждое сообщение сериализуется как стандартное представление protobuf и обменивается между клиентом и удаленной службой.</span><span class="sxs-lookup"><span data-stu-id="49ae6-146">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="49ae6-147">В отличие от JSON или XML, сообщения protobuf сериализуются как скомпилированные двоичные байты.</span><span class="sxs-lookup"><span data-stu-id="49ae6-147">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="49ae6-148">Книга, [gRPC для разработчиков WCF](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), доступная на сайте архитектуры Майкрософт, содержит подробное описание GRPC и буферов протоколов.</span><span class="sxs-lookup"><span data-stu-id="49ae6-148">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="49ae6-149">Поддержка gRPC в .NET</span><span class="sxs-lookup"><span data-stu-id="49ae6-149">gRPC support in .NET</span></span>

<span data-ttu-id="49ae6-150">gRPC интегрирован в пакет SDK для .NET Core 3,0 и более поздней версии.</span><span class="sxs-lookup"><span data-stu-id="49ae6-150">gRPC is integrated into .NET Core 3.0 SDK and later.</span></span> <span data-ttu-id="49ae6-151">Эти средства поддерживают следующие инструменты:</span><span class="sxs-lookup"><span data-stu-id="49ae6-151">The following tools support it:</span></span>

- <span data-ttu-id="49ae6-152">Visual Studio 2019, версия 16,3 или более поздняя, с установленной рабочей нагрузкой веб-разработки.</span><span class="sxs-lookup"><span data-stu-id="49ae6-152">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="49ae6-153">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="49ae6-153">Visual Studio Code</span></span>
- <span data-ttu-id="49ae6-154">интерфейс командной строки DotNet</span><span class="sxs-lookup"><span data-stu-id="49ae6-154">the dotnet CLI</span></span>

<span data-ttu-id="49ae6-155">Пакет SDK включает инструментарий для маршрутизации конечных точек, встроенный IoC и ведение журнала.</span><span class="sxs-lookup"><span data-stu-id="49ae6-155">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="49ae6-156">Веб-сервер Kestrel с открытым кодом поддерживает подключения HTTP/2.</span><span class="sxs-lookup"><span data-stu-id="49ae6-156">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="49ae6-157">На рис. 4-20 показан шаблон Visual Studio 2019, который формирует скелет проекта для службы gRPC.</span><span class="sxs-lookup"><span data-stu-id="49ae6-157">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="49ae6-158">Обратите внимание, что .NET Core полностью поддерживает Windows, Linux и macOS.</span><span class="sxs-lookup"><span data-stu-id="49ae6-158">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![Поддержка gRPC в Visual Studio 2019](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="49ae6-160">**Рис. 4-20**.</span><span class="sxs-lookup"><span data-stu-id="49ae6-160">**Figure 4-20**.</span></span> <span data-ttu-id="49ae6-161">Поддержка gRPC в Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="49ae6-161">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="49ae6-162">На рис. 4-21 показана скелетная служба gRPC, созданная на основе встроенного механизма формирования шаблонов, входящего в Visual Studio 2019.</span><span class="sxs-lookup"><span data-stu-id="49ae6-162">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![проект gRPC в Visual Studio 2019](./media/grpc-project.png  )

<span data-ttu-id="49ae6-164">**Рис. 4-21**.</span><span class="sxs-lookup"><span data-stu-id="49ae6-164">**Figure 4-21**.</span></span> <span data-ttu-id="49ae6-165">проект gRPC в Visual Studio 2019</span><span class="sxs-lookup"><span data-stu-id="49ae6-165">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="49ae6-166">На предыдущем рисунке обратите внимание на файл описания и код службы.</span><span class="sxs-lookup"><span data-stu-id="49ae6-166">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="49ae6-167">Как вы вскоре увидите, Visual Studio создаст дополнительную конфигурацию в классе Startup и базовом файле проекта.</span><span class="sxs-lookup"><span data-stu-id="49ae6-167">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="49ae6-168">Использование gRPC</span><span class="sxs-lookup"><span data-stu-id="49ae6-168">gRPC usage</span></span>

<span data-ttu-id="49ae6-169">Предпочитать gRPC в следующих сценариях:</span><span class="sxs-lookup"><span data-stu-id="49ae6-169">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="49ae6-170">Синхронное взаимодействие микрослужбы с микрослужбой, где требуется немедленное реагирование для продолжения обработки.</span><span class="sxs-lookup"><span data-stu-id="49ae6-170">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="49ae6-171">Polyglot среды, которые должны поддерживать смешанные платформы программирования.</span><span class="sxs-lookup"><span data-stu-id="49ae6-171">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="49ae6-172">Низкая задержка и скорость обмена данными с высокой пропускной способностью, когда важна производительность.</span><span class="sxs-lookup"><span data-stu-id="49ae6-172">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="49ae6-173">Связь "точка-точка" в реальном времени может отправлять сообщения в режиме реального времени без опроса и имеет отличную поддержку двунаправленной потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="49ae6-173">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="49ae6-174">Ограниченные среды сети — двоичные сообщения gRPC всегда меньше, чем эквивалентное текстовое сообщение JSON.</span><span class="sxs-lookup"><span data-stu-id="49ae6-174">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="49ae6-175">На момент написания этой статьи gRPC в основном используется с серверными службами.</span><span class="sxs-lookup"><span data-stu-id="49ae6-175">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="49ae6-176">Современные браузеры не могут предоставить уровень управления HTTP/2, необходимый для поддержки клиентского gRPC клиента.</span><span class="sxs-lookup"><span data-stu-id="49ae6-176">Modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="49ae6-177">С другой стороны, существует поддержка [gRPC-Web с .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) , которая позволяет gRPC взаимодействие из приложений на основе браузера, созданных с помощью JavaScript или Blazor WebAssembly технологий.</span><span class="sxs-lookup"><span data-stu-id="49ae6-177">That said, there's support for [gRPC-Web with .NET](https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="49ae6-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) включает приложение ASP.NET Core gRPC для поддержки функций gRPC в приложениях браузера:</span><span class="sxs-lookup"><span data-stu-id="49ae6-178">[gRPC-Web](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="49ae6-179">Строго типизированные, генерируемые кодом клиенты</span><span class="sxs-lookup"><span data-stu-id="49ae6-179">Strongly typed, code-generated clients</span></span>
- <span data-ttu-id="49ae6-180">Compact protobuf сообщения</span><span class="sxs-lookup"><span data-stu-id="49ae6-180">Compact Protobuf messages</span></span>
- <span data-ttu-id="49ae6-181">Потоковая передача сервера</span><span class="sxs-lookup"><span data-stu-id="49ae6-181">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="49ae6-182">Реализация gRPC</span><span class="sxs-lookup"><span data-stu-id="49ae6-182">gRPC implementation</span></span>

<span data-ttu-id="49ae6-183">Эталонная архитектура микрослужб, [ешоп в контейнерах](https://github.com/dotnet-architecture/eShopOnContainers)от Майкрософт, демонстрирует, как реализовать службы gRPC в приложениях .NET Core.</span><span class="sxs-lookup"><span data-stu-id="49ae6-183">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="49ae6-184">На рисунке 4-22 представлена серверная архитектура.</span><span class="sxs-lookup"><span data-stu-id="49ae6-184">Figure 4-22 presents the back-end architecture.</span></span>

![Серверная архитектура для Ешоп в контейнерах](./media/eshop-with-aggregators.png)

<span data-ttu-id="49ae6-186">**Рис. 4-22**.</span><span class="sxs-lookup"><span data-stu-id="49ae6-186">**Figure 4-22**.</span></span> <span data-ttu-id="49ae6-187">Серверная архитектура для Ешоп в контейнерах</span><span class="sxs-lookup"><span data-stu-id="49ae6-187">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="49ae6-188">На предыдущем рисунке обратите внимание, как Ешоп использует [серверную часть для шаблона интерфейсной части](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (БФФ), предоставляя несколько шлюзов API.</span><span class="sxs-lookup"><span data-stu-id="49ae6-188">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="49ae6-189">Ранее в этой главе мы обсуждали шаблон БФФ.</span><span class="sxs-lookup"><span data-stu-id="49ae6-189">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="49ae6-190">Обратите особое внимание на микрослужбу агрегатора (серым), которая находится между шлюзом API веб-покупок и внутренними службами покупки.</span><span class="sxs-lookup"><span data-stu-id="49ae6-190">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="49ae6-191">Агрегатор получает один запрос от клиента, передает его в различные микрослужбы, объединяет результаты и отправляет их обратно запрашивающему клиенту.</span><span class="sxs-lookup"><span data-stu-id="49ae6-191">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="49ae6-192">Таким операциям обычно требуется синхронное взаимодействие, чтобы получить немедленный ответ.</span><span class="sxs-lookup"><span data-stu-id="49ae6-192">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="49ae6-193">В Ешоп внутренние вызовы из агрегатора выполняются с помощью gRPC, как показано на рис. 4-23.</span><span class="sxs-lookup"><span data-stu-id="49ae6-193">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![gRPC в Ешоп в контейнерах](./media/grpc-implementation.png)

<span data-ttu-id="49ae6-195">**Рис. 4-23**.</span><span class="sxs-lookup"><span data-stu-id="49ae6-195">**Figure 4-23**.</span></span> <span data-ttu-id="49ae6-196">gRPC в Ешоп в контейнерах</span><span class="sxs-lookup"><span data-stu-id="49ae6-196">gRPC in eShop on Containers</span></span>

<span data-ttu-id="49ae6-197">для обмена данными gRPC требуются клиентские и серверные компоненты.</span><span class="sxs-lookup"><span data-stu-id="49ae6-197">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="49ae6-198">На предыдущем рисунке обратите внимание на то, как агрегатор покупок реализует клиент gRPC.</span><span class="sxs-lookup"><span data-stu-id="49ae6-198">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="49ae6-199">Клиент выполняет синхронные вызовы gRPC (красным) в серверные микрослужбы, каждый из которых реализует сервер gRPC.</span><span class="sxs-lookup"><span data-stu-id="49ae6-199">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="49ae6-200">Как клиент, так и сервер используют преимущества встроенных gRPCных коммуникаций из пакет SDK для .NET Core.</span><span class="sxs-lookup"><span data-stu-id="49ae6-200">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core SDK.</span></span> <span data-ttu-id="49ae6-201">Клиентские *заглушки* предоставляют механизм для вызова удаленных вызовов gRPC.</span><span class="sxs-lookup"><span data-stu-id="49ae6-201">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="49ae6-202">Серверные компоненты предоставляют gRPCные коммуникации, которые могут наследовать и использовать пользовательские классы служб.</span><span class="sxs-lookup"><span data-stu-id="49ae6-202">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="49ae6-203">Микрослужбы, которые предоставляют как API RESTFUL, так и gRPC обмен данными, нуждаются в нескольких конечных точках для управления трафиком.</span><span class="sxs-lookup"><span data-stu-id="49ae6-203">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="49ae6-204">Вы откроете конечную точку, которая прослушивает HTTP-трафик для вызовов RESTFUL, а другой — для вызовов gRPC.</span><span class="sxs-lookup"><span data-stu-id="49ae6-204">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="49ae6-205">Конечная точка gRPC должна быть настроена для протокола HTTP/2, необходимого для обмена данными gRPC.</span><span class="sxs-lookup"><span data-stu-id="49ae6-205">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="49ae6-206">Хотя мы стремимся разделять микрослужбы с помощью асинхронных шаблонов связи, некоторым операциям требуются прямые вызовы.</span><span class="sxs-lookup"><span data-stu-id="49ae6-206">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="49ae6-207">gRPC должен быть основным выбором для прямого синхронного взаимодействия между микрослужбами.</span><span class="sxs-lookup"><span data-stu-id="49ae6-207">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="49ae6-208">Его высокопроизводительный протокол связи, основанный на HTTP/2 и буферах протоколов, делает его идеальным выбором.</span><span class="sxs-lookup"><span data-stu-id="49ae6-208">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="49ae6-209">Взгляд на будущее</span><span class="sxs-lookup"><span data-stu-id="49ae6-209">Looking ahead</span></span>

<span data-ttu-id="49ae6-210">Взглянув на gRPC, вы продолжите работать с собственными системами в облаке.</span><span class="sxs-lookup"><span data-stu-id="49ae6-210">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="49ae6-211">Преимущества производительности и простота разработки очень привлекательны.</span><span class="sxs-lookup"><span data-stu-id="49ae6-211">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="49ae6-212">Однако, скорее всего, в течение длительного времени все будет работать.</span><span class="sxs-lookup"><span data-stu-id="49ae6-212">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="49ae6-213">Он предназначен для общедоступных API-интерфейсов и для обеспечения обратной совместимости.</span><span class="sxs-lookup"><span data-stu-id="49ae6-213">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="49ae6-214">[Назад](service-to-service-communication.md)
>[Вперед](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="49ae6-214">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
