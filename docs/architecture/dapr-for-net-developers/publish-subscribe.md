---
title: Стандартный блок ДАПР Publishing & Subscribe
description: Описание ДАПР Publishing & Subscribe, а также способы его применения
author: edwinvw
ms.date: 02/07/2021
ms.openlocfilehash: 3d00c5a3171dd5a7287d07675f5a3742697e784b
ms.sourcegitcommit: 9c589b25b005b9a7f87327646020eb85c3b6306f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/06/2021
ms.locfileid: "102401919"
---
# <a name="the-dapr-publish--subscribe-building-block"></a>Стандартный блок ДАПР Publishing & Subscribe

[Шаблон публикации-подписки](/azure/architecture/patterns/publisher-subscriber) (часто называется "Pub/republish") — это хорошо известная и широко используемая схема обмена сообщениями. Архитекторы часто используют его в распределенных приложениях. Однако их реализация может быть сложной. Часто различия между компонентами различных продуктов обмена сообщениями являются незаметными. ДАПР предлагает стандартный блок, который значительно упрощает реализацию функций Pub/подкаталога.

## <a name="what-it-solves"></a>Решение

Основное преимущество шаблона Publish-Subscribe — **слабая** связь, которая иногда называется [временной](/azure/architecture/guide/technology-choices/messaging#decoupling)разсоединением. Шаблон отделяет службы, отправляющие сообщения ( **Издатели**) от служб, которые используют сообщения ( **Подписчики**). Как издатели, так и подписчики не знают друг о друга. они зависят от централизованного **брокера сообщений** , который распространяет сообщения.

На рис. 7-1 показана высокоуровневая архитектура шаблона публикации и подкаталогов.

![Шаблон публикации и подпапки](./media/publish-subscribe/pub-sub-pattern.png)

**Рис. 7-1**. Шаблон публикации и подпапки.

На предыдущем рисунке обратите внимание на шаги шаблона:

1. Издатели отправляют сообщения в брокер сообщений.
1. Подписчики привязываются к подписке в брокере сообщений.
1. Брокер сообщений пересылает копию сообщения заинтересованным подпискам.
1. Подписчики используют сообщения из своих подписок.

Большинство брокеров сообщений инкапсулируют механизм очередей, который может сохранять сообщения после получения. С его помощью брокер сообщений гарантирует **устойчивость** , сохранив сообщение. Подписчики не должны быть доступны немедленно или даже в режиме в сети, когда издатель отправляет сообщение. После получения доступа подписчик получает и обрабатывает сообщение.  ДАПР гарантирует как **минимум одну** семантику доставки сообщений. После публикации сообщения оно будет доставлено хотя бы одному заинтересованному подписчику.

 > Если служба может обработать сообщение только один раз, необходимо предоставить [проверку идемпотентности](/azure/architecture/microservices/design/api-design#idempotent-operations) , чтобы убедиться, что одно и то же сообщение не обрабатывается несколько раз. Хотя такую логику можно закодировать, некоторые брокеры сообщений, например служебная шина Azure, предоставляют встроенные возможности обмена сообщениями об *обнаружении дубликатов* .

Доступно несколько продуктов брокера сообщений — как коммерческих, так и с открытым кодом. У каждого есть свои преимущества и недостатки. Ваше задание должно соответствовать требованиям к системе для соответствующего брокера. После выбора рекомендуется отделить приложение от коммуникаций брокера сообщений. Эту функциональность можно реализовать, заключив брокер внутрь *абстракции*. Абстракция инкапсулирует механизм обмена сообщениями и предоставляет в код универсальные операции публикации и подмножества. Код взаимодействует с абстракцией, а не с реальным посредником сообщений. При разумном принятии решения вам придется писать и поддерживать абстракцию и ее базовую реализацию. Этот подход требует использования пользовательского кода, который может быть сложным, повторяющимися и подверженным ошибкам.

Стандартный блок ДАПР Publish & подписки предоставляет абстракцию и реализацию сообщения. Пользовательский код, который пришлось бы писать, является предварительно созданным и инкапсулированным в стандартном блоке ДАПР. Выполняется привязка к нему и его использование. Вместо написания кода для обмена сообщениями вы и ваша команда сосредоточены на создании бизнес-функций, которые расширяют ценность для клиентов.

## <a name="how-it-works"></a>Принцип работы

Стандартный блок ДАПР Publish & Subscribe предоставляет платформу API, не зависящую от платформы, для отправки и получения сообщений. Ваши службы публикуют сообщения в именованном [разделе](/azure/service-bus-messaging/service-bus-queues-topics-subscriptions#topics-and-subscriptions). Ваши службы подписываются на тему для использования сообщений.

Служба вызывает API Pub/подпрограммы на ДАПР расширения. Затем расширения обращается к предварительно определенному компоненту ДАПР Pub/подразделу, который инкапсулирует конкретный продукт брокера сообщений. На рисунке 7-2 показан стек сообщений ДАПР Pub/подразделов.

![Стек публикации и поддерева](./media/publish-subscribe/pub-sub-buildingblock.png)

**Рис. 7-2**. Стек Pub/ДАПР.

Стандартный блок ДАПР Publish & Subscribe может вызываться множеством способов.

На самом низком уровне любая платформа программирования может вызывать Стандартный блок по протоколу HTTP или gRPC с помощью **собственного API ДАПР**. Чтобы опубликовать сообщение, необходимо выполнить следующий вызов API:

``` http
http://localhost:<dapr-port>/v1.0/publish/<pub-sub-name>/<topic>
```

Существует несколько ДАПР сегментов URL-адресов в приведенном выше вызове:

- `<dapr-port>` предоставляет номер порта, на котором прослушивается расширения ДАПР.
- `<pub-sub-name>` предоставляет имя выбранного компонента ДАПР Pub/подтипа.
- `<topic>` предоставляет имя раздела, в который публикуется сообщение.

С помощью *инструмента командной строки* для публикации сообщения можно попробовать выполнить следующие действия:

``` curl
curl -X POST http://localhost:3500/v1.0/publish/pubsub/newOrder \
  -H "Content-Type: application/json" \
  -d '{ "orderId": "1234", "productId": "5678", "amount": 2 }'
```

Вы получаете сообщения, подписавшись на раздел. При запуске среда выполнения ДАПР будет вызывать приложение на известной конечной точке для обнаружения и создания необходимых подписок:

``` http
http://localhost:<appPort>/dapr/subscribe
```

- `<appPort>` информирует ДАПР расширения порта, на котором приложение прослушивается.

Эту конечную точку можно реализовать самостоятельно. Но ДАПР предоставляет более интуитивно понятные способы реализации. Эта функция будет устранена далее в этой главе.

Ответ вызова содержит список разделов, на которые будут подписываться приложения. Каждый из них включает конечную точку, которая вызывается, когда раздел получает сообщение. Вот пример ответа:

```json
[
  {
    "pubsubname": "pubsub",
    "topic": "newOrder",
    "route": "/orders"
  },
  {
    "pubsubname": "pubsub",
    "topic": "newProduct",
    "route": "/productCatalog/products"
  }
]
```

В ответе JSON можно увидеть, что приложение хочет подписываться на разделы `newOrder` и `newProduct` . Он регистрирует конечные точки `/orders` и `/productCatalog/products` для каждого, соответственно. Для обеих подписок приложение привязывается к компоненту ДАПР с именем `pubsub` .

На рис. 7-3 представлен поток примера.

![Пример потока публикации и подсистемы с помощью ДАПР](media/publish-subscribe/pub-sub-flow.png)

**Рис. 7-3**. поток Pub/с ДАПР.

На предыдущем рисунке обратите внимание на последовательность:

1. ДАПР расширения для службы B вызывает `/dapr/subscribe` конечную точку из службы b (потребителя). Служба реагирует на подписки, которые необходимо создать.
1. ДАПР расширения для службы B создает запрошенные подписки на брокере сообщений.
1. Служба а публикует сообщение в `/v1.0/publish/<pub-sub-name>/<topic>` конечной точке в службе ДАПР A расширения.
1. Служба A расширения публикует сообщение в брокер сообщений.
1. Брокер сообщений отправляет копию сообщения в службу B расширения.
1. Служба B расширения вызывает конечную точку, соответствующую подписке (в данном случае `/orders` ), в службе б. Служба реагирует на код состояния HTTP, `200 OK` поэтому расширения будет рассматривать сообщение как обработанное успешно.

В этом примере сообщение обработано успешно. Но если что-то пошло не так, когда служба б обрабатывает запрос, она может использовать ответ, чтобы указать, что должно происходить с сообщением. Когда он возвращает код состояния HTTP `404` , регистрируется ошибка и сообщение удаляется. При наличии любого другого кода состояния `200` `404` , который больше или, предупреждение регистрируется и сообщение повторяется. Кроме того, служба б может явно указать, что должно происходить с сообщением, включив полезные данные JSON в текст ответа:

```json
{
  "status": "<status>"
}
```

Доступные значения приведены в следующей таблице `status` .

| Состояние           | Действие                                                       |
| ---------------- | ------------------------------------------------------------ |
| УСПЕШНОЕ ЗАВЕРШЕНИЕ          | Сообщение считается обработанным успешно и удалено. |
| ПОВТОРИТЬ            | Сообщение повторяется.                                      |
| DROP             | В журнал заносится предупреждение и сообщение удаляется.              |
| Любое другое состояние | Сообщение повторяется.                                      |

### <a name="competing-consumers"></a>Конкурирующие потребители

При масштабировании приложения, которое подписывается на раздел, необходимо работать с конкурирующими потребителями. Только один экземпляр приложения должен работать с сообщением, отправленным в раздел. К счастью, ДАПР обрабатывает эту проблему. Когда несколько экземпляров службы с одним и тем же идентификатором приложения подписываются на раздел, ДАПР доставляет каждое сообщение только одному из них.

### <a name="sdks"></a>Пакеты SDK

Выполнение HTTP-вызовов к собственным ДАПР API-интерфейсам занимает много времени и является абстрактным. Вызовы разрабатываются на уровне HTTP, и вам нужно будет решить такие проблемы, как сериализация и коды ответов HTTP. К счастью, существует более интуитивно понятный способ. ДАПР предоставляет несколько пакетов SDK для конкретных языков для популярных платформ разработки. На момент написания этой статьи доступны Node.js, Python, .NET, Java и JavaScript.

## <a name="use-the-dapr-net-sdk"></a>Использование пакета SDK для ДАПР .NET

Для разработчиков .NET [пакет SDK для ДАПР .NET](https://www.nuget.org/packages/Dapr.Client) предоставляет более эффективный способ работы с ДАПР. Пакет SDK предоставляет `DaprClient` класс, с помощью которого можно напрямую вызывать функции ДАПР. Он интуитивно понятен и удобен в использовании.

Чтобы опубликовать сообщение, объект `DaprClient` предоставляет `PublishEventAsync` метод.

```csharp
var data = new OrderData
{
  orderId = "123456",
  productId = "67890",
  amount = 2
};

var daprClient = new DaprClientBuilder().Build();

await daprClient.PublishEventAsync<OrderData>("pubsub", "newOrder", data);
```

- Первым аргументом `pubsub` является имя компонента ДАПР, предоставляющего реализацию брокера сообщений. Далее в этой главе мы будем обращаться к компонентам.
- Второй аргумент `neworder` предоставляет имя раздела, в который отправляется сообщение.
- Третьим аргументом является полезная нагрузка сообщения.
- Тип .NET сообщения можно указать с помощью параметра универсального типа метода.

Чтобы получить сообщения, необходимо привязать конечную точку к подписке для зарегистрированного раздела. Библиотека AspNetCore для ДАПР делает это тривиальным. Предположим, например, что у вас есть метод действия WebAPI ASP.NET, имеющий право `CreateOrder` :

```csharp
[HttpPost("/orders")]
public async Task<ActionResult> CreateOrder(Order order)
```

 > Чтобы использовать интеграцию с ДАПР ASP.NET Core, необходимо добавить ссылку на пакет NuGet [ДАПР. AspNetCore](https://www.nuget.org/packages/Dapr.AspNetCore) в проекте.

Чтобы привязать этот метод действия к разделу, необходимо снабдить его `Topic` атрибутом:

```csharp
[Topic("pubsub", "newOrder")]
[HttpPost("/orders")]
public async Task<ActionResult> CreateOrder(Order order)
```

Вы указываете два ключевых элемента с помощью этого атрибута:

- Целевой компонент ДАПР Pub/подкаталог (в данном случае `pubsub` ).
- Раздел, на который подписывается (в данном случае `newOrder` ).

Затем ДАПР вызывает этот метод действия, когда он получает сообщения для этого раздела.

Также необходимо включить ASP.NET Core для использования ДАПР. Пакет SDK для ДАПР .NET предоставляет несколько методов расширения, которые могут быть вызваны в `Startup` классе.

В `ConfigureServices` методе необходимо добавить следующий метод расширения:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    // ...
    services.AddControllers().AddDapr();
}
```

Добавление `AddDapr` метода расширения в `AddControllers` метод Extension регистрирует необходимые службы для интеграции ДАПР в конвейер MVC. Он также регистрирует `DaprClient` экземпляр в контейнере внедрения зависимостей, который затем может быть внедрен в любую службу.

В `Configure` методе необходимо добавить следующие компоненты по промежуточного слоя для включения ДАПР:

```csharp
public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    // ...
    app.UseCloudEvents();

    app.UseEndpoints(endpoints =>
    {
        endpoints.MapSubscribeHandler();
        // ...
    });
}
```

Вызов добавляет по `UseCloudEvents` промежуточного слоя **клаудевентс** в конвейер по промежуточного слоя ASP.NET Core. Это по промежуточного слоя будет распаковывать запросы, использующие структурированный формат Клаудевентс, поэтому метод получения может считывать полезные данные события напрямую.

> [Клаудевентс](https://cloudevents.io/) — это стандартизированный формат обмена сообщениями, предоставляющий общий способ описания сведений о событиях на разных платформах. ДАПР охватывает Клаудевентс. Дополнительные сведения о Клаудевентс см. в [спецификации клаудевентс](https://github.com/cloudevents/spec/tree/v1.0).

При вызове `MapSubscribeHandler` в конфигурации маршрутизации конечной точки в приложение будет добавлена конечная точка подписки ДАПР. Эта конечная точка будет отвечать на запросы `/dapr/subscribe` . При вызове этой конечной точки он автоматически находит все методы действий WebAPI, снабженные `Topic` атрибутом, и указывает ДАПР создать для них подписки.

## <a name="pubsub-components"></a>Компоненты публикации и подраздела

[Компоненты Pub/](https://github.com/dapr/components-contrib/tree/master/pubsub) поддапр обработают фактический транспорт сообщений. Доступны несколько. Каждый из них инкапсулирует конкретный продукт брокера сообщений для реализации функции Pub/подтипа. На момент написания статьи были доступны следующие компоненты публикации и подкаталогов:

- Apache Kafka
- Центры событий Azure
- Azure Service Bus
- AWS SNS/СКС
- ОБЕСПЕЧИТЬ Pub/Re-in
- хазелкаст
- MQTT
- NATS
- пулсар
- RabbitMQ
- Потоки Redis

> [!NOTE]
> В облачном стеке Azure доступны обе функции: обмен сообщениями (служебная шина Azure) и потоковая передача событий (концентратор событий Azure).

Эти компоненты создаются сообществом в [репозитории Component-от участников сообщества на сайте GitHub](https://github.com/dapr/components-contrib/tree/master/pubsub). Вы можете написать собственный компонент ДАПР для брокера сообщений, который еще не поддерживается.

### <a name="configure-pubsub-components"></a>Настройка компонентов публикации и подразделов

С помощью файла конфигурации ДАПР можно указать компоненты публикации и подсистемы, которые будут использоваться. Эта конфигурация содержит несколько полей. В этом `name` поле указывается компонент Pub/подсистемы, который вы хотите использовать. При отправке или получении сообщения необходимо указать это имя (как было показано ранее в `PublishEventAsync` сигнатуре метода).

Ниже приведен пример файла конфигурации ДАПР для настройки компонента брокера сообщений RabbitMQ:

```yaml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: pubsub-rq
spec:
  type: pubsub.rabbitmq
  version: v1
  metadata:
  - name: host
    value: "amqp://localhost:5672"
  - name: durable
    value: true
```

В этом примере можно увидеть, что в блоке можно указать любую конфигурацию брокера сообщений `metadata` . В этом случае RabbitMQ настроен для создания устойчивых очередей. Но у компонента RabbitMQ больше параметров конфигурации. Каждая конфигурация компонентов будет иметь собственный набор возможных полей. Можно прочитать, какие поля доступны в документации по каждому [компоненту Pub/подтип](https://docs.dapr.io/operations/components/setup-pubsub/supported-pubsub/).

Рядом с программным способом подписки на раздел кода ДАПР Pub/поддает также декларативный способ подписки на раздел. Этот подход удаляет зависимость ДАПР из кода приложения. Таким образом, оно также позволяет существующему приложению подписываться на разделы без внесения изменений в код. В следующем примере показан файл конфигурации ДАПР для настройки подписки.

```yaml
apiVersion: dapr.io/v1alpha1
kind: Subscription
metadata:
  name: newOrder-subscription
spec:
  pubsubname: pubsub
  topic: newOrder
  route: /orders
scopes:
- ServiceB
- ServiceC
```

Необходимо указать несколько элементов с каждой подпиской:

- Имя подкомпонента ДАПР Pub/подтипа, который вы хотите использовать (в данном случае `pubsub` ).
- Имя раздела для подписки (в данном случае `newOrder` ).
- Операция API, которая должна вызываться для этого раздела (в данном случае `/orders` ).
- В [области](https://docs.dapr.io/developing-applications/building-blocks/pubsub/pubsub-scopes/) можно указать, какие службы могут публиковать и подписываться на раздел.

## <a name="reference-application-eshopondapr"></a>Эталонное приложение: Ешопондапр

Сопутствующее приложение [ешопондапр](https://github.com/dotnet-architecture/eShopOnDapr) предоставляет комплексную эталонную архитектуру для создания приложения микрослужб, реализующего ДАПР. Ешопондапр — это эволюция широко популярного [eShopOnContainers](https://github.com/dotnet-architecture/eShopOnContainer) приложения, созданного несколько лет назад. В обеих версиях используется шаблон публикации и поддела для обмена [событиями интеграции](https://devblogs.microsoft.com/cesardelatorre/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/#integration-events) между микрослужбами. К событиям интеграции относятся:

- Когда пользователь извлекает корзину покупок.
- При успешном платеже заказа.
- По истечении периода отсрочки покупки.

События в eShopOnContainers основаны на следующем `IEventBus` интерфейсе:

```csharp
public interface IEventBus
{
    void Publish(IntegrationEvent integrationEvent);

    void Subscribe<T, THandler>()
        where TEvent : IntegrationEvent
        where THandler : IIntegrationEventHandler<T>;
}
```

Конкретные реализации этого интерфейса существуют в eShopOnContainers как для RabbitMQ, так и для служебной шины Azure. Каждая реализация включает в себя большой объем пользовательского коммуникационного кода, который был сложным для понимания и сложно поддерживать.

Более новая Ешопондапр значительно упрощает поведение публикации и подменю с помощью ДАПР. Например, `IEventBus` интерфейс был уменьшен до одного метода:

```csharp
public interface IEventBus
{
    Task PublishAsync(IntegrationEvent integrationEvent);
}
```

### <a name="publish-events"></a>Публикация событий

В обновленном Ешопондапр одна `DaprEventBus` реализация может поддерживать любой брокер сообщений, поддерживаемый ДАПР. В следующем блоке кода показан упрощенный метод публикации. Обратите внимание, что `PublishAsync` метод использует клиент ДАПР для публикации события:

```csharp
public class DaprEventBus : IEventBus
{
    private const string PubSubName = "pubsub";

    private readonly DaprClient _daprClient;
    private readonly ILogger<DaprEventBus> _logger;

    public DaprEventBus(DaprClient daprClient, ILogger<DaprEventBus> logger)
    {
        _daprClient = daprClient ?? throw new ArgumentNullException(nameof(daprClient));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task PublishAsync(IntegrationEvent integrationEvent)
    {
        var topicName = integrationEvent.GetType().Name;

        // Dapr uses System.Text.Json which does not support serialization of a
        // polymorphic type hierarchy by default. Using object as the type
        // parameter causes all properties to be serialized.
        await _daprClient.PublishEventAsync<object>(PubSubName, topicName, integrationEvent);
    }
}
```

Как видно в фрагменте кода, имя раздела является производным от имени типа события. Так как все службы Ешоп используют `IEventBus` абстракцию, модернизация ДАПР *не требует изменений* в коде приложения магистрали.

> [!IMPORTANT]
> Пакет SDK ДАПР использует `System.Text.Json` для сериализации и десериализации сообщений. Однако `System.Text.Json` по умолчанию не Сериализует свойства производных классов. В коде Ешоп событие иногда явно объявляется как `IntegrationEvent` , базовым классом для событий интеграции. Это делается потому, что конкретный тип события определяется динамически во время выполнения на основе бизнес-логики. В результате событие сериализуется с использованием сведений о типе базового класса, а не производного класса. Чтобы принудительно `System.Text.Json` сериализовать все свойства производного класса в этом случае, код использует в `object` качестве параметра универсального типа. Дополнительные сведения см. в [документации по .NET](../../standard/serialization/system-text-json-polymorphism.md).

С помощью ДАПР код инфраструктуры **значительно упрощен**. Не нужно различать различные брокеры сообщений. ДАПР предоставляет эту абстракцию. При необходимости можно легко поменять местами брокеры сообщений или настроить несколько компонентов брокера сообщений.

### <a name="subscribe-to-events"></a>Оформление подписки на события

Предыдущее приложение eShopOnContainers содержит *SubscriptionManagers* для поддержки реализации подписки для каждого брокера сообщений. Каждый диспетчер содержит сложный код брокера сообщений для обработки событий подписки. Для получения событий каждая служба должна явным образом зарегистрировать обработчик для каждого типа события.

Ешопондапр упрощает работу с подписками на события с помощью библиотек ASP.NET Core ДАПР. Каждое событие обрабатывается методом действия в контроллере. Атрибут добавляет к `Topic` методу действия имя соответствующего раздела для подписки. Ниже приведен фрагмент кода, взятый из `PaymentService` :

```csharp
[Route("api/v1/[controller]")]
[ApiController]
public class IntegrationEventController : ControllerBase
{
    private const string DAPR_PUBSUB_NAME = "pubsub";

    private readonly IServiceProvider _serviceProvider;

    public IntegrationEventController(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    [HttpPost("OrderStatusChangedToValidated")]
    [Topic(DAPR_PUBSUB_NAME, "OrderStatusChangedToValidatedIntegrationEvent")]
    public async Task OrderStarted(OrderStatusChangedToValidatedIntegrationEvent integrationEvent)
    {
        var handler = _serviceProvider.GetRequiredService<OrderStatusChangedToValidatedIntegrationEventHandler>();
        await handler.Handle(integrationEvent);
    }
}
```

В `Topic` атрибуте имя типа .NET для события используется в качестве имени раздела. Для обработки события вызывается обработчик событий, который уже существовал в более ранней базе кода eShopOnContainers. В предыдущем примере сообщения, полученные из раздела, `OrderStatusChangedToValidatedIntegrationEvent` вызывают существующий `OrderStatusChangedToValidatedIntegrationEventHandler` обработчик событий. Поскольку ДАПР реализует базовые коммуникации для подписок и брокеров сообщений, большой объем исходного кода стал устаревшим и был удален из базы кода. Большая часть этого кода была сложной для понимания и сложной в обслуживании.

### <a name="use-pubsub-components"></a>Использование компонентов Pub/подразделов

В репозитории Ешопондапр `deployment` Папка содержит файлы для развертывания приложения с использованием различных режимов развертывания: `Docker Compose` и `Kubernetes` . `dapr`Папка существует в каждой из этих папок, где хранится `components` Папка. Эта папка содержит файл, `eshop-pubsub.yaml` содержащий конфигурацию компонента ДАПР Pub/подпрограммы, которую приложение будет использовать для публикации и вложенности. Как было показано в предыдущих фрагментах кода, имя используемого компонента публикации и подраздела — `pubsub` . Вот содержимое `eshop-pubsub.yaml` файла в `deployment/compose/dapr/components` папке:

```yaml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: pubsub
  namespace: default
spec:
  type: pubsub.nats
  version: v1
  metadata:
  - name: natsURL
    value: nats://demo.nats.io:4222
```

В приведенной выше конфигурации для этого примера указан необходимый [брокер сообщений NAT](https://nats.io/) . Чтобы изменить брокеры сообщений, необходимо настроить другой брокер сообщений, например RabbitMQ или служебную шину Azure, и обновить файл YAML. В ДАПР нет изменений в коде службы магистрали при переключении брокеров сообщений.

Наконец, вы можете спросить: «Зачем мне нужен несколько брокеров сообщений в приложении?». В большинстве случаев система будет выполнять рабочие нагрузки с различными характеристиками. Одно событие может происходить 10 раз в день, но другое событие происходит 5 000 раз в секунду. Вы можете воспользоваться преимуществами, разбейте трафик сообщений на разные брокеры сообщений. С помощью ДАПР можно добавить несколько конфигураций компонентов публикации и подраздела, каждый из которых имеет другое имя.

## <a name="summary"></a>Итоги

Шаблон Pub/Re-in позволяет отделить службы в распределенном приложении. Стандартный блок ДАПР Publish & Subscribe упрощает реализацию этого поведения в приложении.

С помощью ДАПР Pub/Publish можно публиковать сообщения в определенном *разделе*. Кроме того, Стандартный блок запрашивает службу, чтобы определить, на какие разделы следует подписываться.

Вы можете использовать ДАПР Pub/подкаталог в собственном формате по протоколу HTTP или с помощью одного из пакетов SDK для конкретного языка, например пакета SDK для .NET для ДАПР. Пакет SDK для .NET тесно интегрируется с платформой ASP.NET Core.

С помощью ДАПР вы можете подключить к приложению поддерживаемый продукт брокера сообщений. Затем можно поменять местами брокеры сообщений, не требуя изменения кода в приложении.

> [!div class="step-by-step"]
> [Назад](service-invocation.md)
> [Вперед](bindings.md)
