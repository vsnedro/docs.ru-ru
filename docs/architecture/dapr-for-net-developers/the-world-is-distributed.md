---
title: Мир распределенных систем
description: Преимущества и сложности распределенных приложений с использованием монолитных и SOA-подходов.
author: robvet
ms.date: 02/07/2021
ms.openlocfilehash: b857355880c3942526d751312d98f2b822704759
ms.sourcegitcommit: 42d436ebc2a7ee02fc1848c7742bc7d80e13fc2f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/04/2021
ms.locfileid: "102401834"
---
# <a name="the-world-is-distributed"></a>Мир распределенных систем

Просто спросите любой "замечательный ребенок": *современные, распределенные системы в, а монолитные приложения истекает!*

Но это не просто «замечательные дети». Прогрессивные ИТ-руководители, корпоративные архитекторы и разработчики внимательныйи выводят на экран те же идеи, что и исследование и оценка современных распределенных приложений. Многие были приобретены в. Они разрабатывает новые и Реконструирование существующих корпоративных приложений, следуя принципам, шаблонам и методикам распределенных приложений микрослужб.

Но эта эволюция создает множество вопросов...

- Что такое распределенное приложение?
- Почему они получают популярность?
- Каковы затраты?
- И, что важно, каковы компромиссы?

Для начала давайте перейдем назад и взглянем за последние 15 лет. В течение этого периода мы обычно создавали приложения в виде единой монолитной единицы. На рис. 1-1 показана архитектура.

![Монолитная архитектура.](./media/the-world-is-distributed/monolithic-design.png)

**Рис. 1-1**. Монолитная архитектура.

Обратите внимание, как модули для упорядочивания, идентификации и маркетинга выполняются в односерверном процессе. Данные приложения хранятся в общей базе данных. Бизнес-функции предоставляются через интерфейсы HTML и RESTFUL.

Во многих отношениях монолитные приложения являются `straightforward` . Они просты в выполнении:

- Сборка
- Тестирование
- Развернуть
- Устранение неполадок
- Вертикальное масштабирование (увеличение масштаба)

Однако монолитные архитектуры могут представлять значительные трудности.

Со временем вы можете достичь точки, в которой начинается потеря контроля...

- Монолитный поток стал настолько запутанным, что никто не понимает его.
- Вы не вносите изменения, так как каждый из них приводит к непредвиденным и дорогостоящим побочным эффектам.
- Новые функции и исправления становятся трудоемкими и затратными для реализации.
- Даже наименьшее изменение требует полного развертывания всего приложения и его рискованного использования.
- Один нестабильный компонент может вызвать сбой всей системы.
- Добавление новых технологий и платформ не является допустимым вариантом.
- Реализация методологий гибкой доставки не сложнее.
- Архитектура еросион в качестве базы кода приводит к невозможности «незавершенных» особых случаев.
- В конечном итоге консультанты приходят и сообщат вам переписать их.

Специалисты по ИТ вызывают это условие `the Fear Cycle` . Если вы уже работали со специалистами по технологиям в течение какого-то периода времени, вы можете познакомиться с этим. Это нагружает и выходит за пределы ИТ. Вместо создания новых и инновационных решений большая часть вашего бюджета тратится на поддержку устаревших приложений.

Вместо того, чтобы вынуждать в бизнесе, требуется `speed and agility` . Они ищут архитектурный стиль, с помощью которого они могут быстро реагировать на условия рынка. Они должны мгновенно обновлять и индивидуально масштабировать небольшие области интерактивного приложения.

Более ранняя попытка получить скорость и гибкость появилась в виде архитектуры, [ориентированной на службы](https://en.wikipedia.org/wiki/Service-oriented_architecture), или `SOA` . В этой модели потребители служб и поставщики служб совместно используют компоненты для обмена сообщениями по промежуточного слоя, часто называемые [корпоративной шиной обслуживания](https://en.wikipedia.org/wiki/Enterprise_service_bus)или `ESB` . На рис. 1-2 показана архитектура.

![Архитектура.](./media/the-world-is-distributed/soa-basic.png)

**Рис. 1-2**. Архитектура SOA.

С помощью SOA централизованные поставщики услуг, зарегистрированные в ESB. Бизнес-логика будет встроена в ESB для интеграции поставщиков и потребителей. Потребители служб могут затем находить эти поставщики и взаимодействовать с ними с помощью ESB.

Несмотря на обещание SOA, реализация такого подхода часто повышает сложность и предлагает узкие места. Затраты на обслуживание стали высокими, и по промежуточному плану ESB дорого. Службы, как правило, имеют большой размер. Они часто являются общими зависимостями и хранилищем данных. В итоге SOA часто приводит к созданию распределенной структуры с централизованными службами, которые были защищены от изменения.

Настоящее время, многие организации применяют скорость и гибкость, применяя архитектурный подход к созданию систем на основе архитектуры распределенных микрослужб. На рис. 1-3 показана система, созданная с использованием распределенных методик и методик.

![Распределенная архитектура.](./media/the-world-is-distributed/distributed-design.png)

**Рис. 1-3**. Распределенная архитектура.

Обратите внимание, что одно и то же приложение разбивается по набору распределенных служб. Каждый из них самодостаточен и инкапсулирует собственный код, данные и зависимости. Каждый из них развертывается в контейнере программного обеспечения и управляется контейнером Orchestrator. Вместо единственной базы данных, совместно используемой несколькими службами, каждая служба владеет частной базой данных. Другие службы не имеют прямой доступ к этой базе данных и могут получить только данные, предоставляемые через общедоступный API службы, которой она принадлежит. Обратите внимание, что некоторым службам требуется полная реляционная база данных, а другие — хранилище данных NoSQL. Служба корзины хранит свое состояние в распределенном кэше ключей и значений. Обратите внимание, как входящий трафик перенаправляется через службу шлюза API. Он отвечает за направление вызовов к службам и применение перекрестной задачи. Что важнее всего, приложение использует все преимущества функций масштабируемости, доступности и устойчивости, имеющихся в современных облачных платформах.

Однако, в то время как распределенные службы обеспечивают гибкость и скорость, они представляют собой разные наборы проблем. Рассмотрим следующее...

- Как распределенные службы могут обнаруживать друг друга и обмениваться данными синхронно?
- Как они могут реализовать асинхронный обмен сообщениями?
- Как они могут поддерживать контекстную информацию в рамках транзакции?
- Как они могут быть устойчивыми к сбоям?
- Как они могут масштабироваться в соответствии с колебаниями спроса?
- Как они отслеживаются и наблюдаются?

Для каждой из этих задач часто доступны несколько продуктов. Однако экранирование приложения от различий к продуктам и обеспечение поддержки и переносимости кода становится проблемой.

В этой книге представлены ДАПР. ДАПР — это распределенная среда выполнения приложения. Он напрямую решает многие из обнаруженных проблем вместе с распределенными приложениями. Глядя на то, что ДАПР может иметь более глубокое воздействие на разработку распределенных приложений.

## <a name="summary"></a>Итоги

В этой главе мы обсуждали внедрение распределенных приложений. Мы отменяем монолитный подход к работе с распределенными службами. Мы указали многие распространенные проблемы при рассмотрении распределенного подхода.

Теперь вы можете переключить свою работу и подать нам новый мир ДАПР.

>[!div class="step-by-step"]
>[Назад](foreword.md)
>[Вперед](dapr-at-20000-feet.md)
