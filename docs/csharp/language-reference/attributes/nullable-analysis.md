---
title: 'Зарезервированные атрибуты C#: статический анализ типов, допускающих значения NULL'
ms.date: 04/14/2020
description: Компилятор интерпретирует эти атрибуты для более эффективного статического анализа ссылочных типов, допускающих значения NULL и не допускающих значения NULL.
ms.openlocfilehash: d2405162ece3df209111de65fdef54f70cc86d45
ms.sourcegitcommit: 1e8382d0ce8b5515864f8fbb178b9fd692a7503f
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2020
ms.locfileid: "89656316"
---
# <a name="reserved-attributes-contribute-to-the-compilers-null-state-static-analysis"></a>Зарезервированные атрибуты используются для статического анализа состояния NULL компилятора.

В контексте, допускающем значения NULL, компилятор выполняет статический анализ кода для определения состояния со значением NULL всех переменных ссылочного типа.

- *Значение, отличное от NULL*. Статический анализ определил, что переменной присвоено значение, отличное от NULL.
- *Может иметь значение NULL*. Статический анализ не может определить, что переменной присвоено значение, отличное от NULL.

Можно применить ряд атрибутов, предоставляющих компилятору сведения о семантике API-интерфейсов. Эти сведения помогают компилятору выполнять статический анализ и определять, когда переменная не имеет значение NULL. В этой статье приводится краткое описание каждого из этих атрибутов и рассматриваются способы их использования. Во всех примерах предполагается, что используется C# 8.0 или более поздняя версия, а код находится в контексте, допускающем значения NULL.

Начнем со знакомого примера. Представьте, что библиотека содержит следующий API для получения строки ресурса.

```csharp
bool TryGetMessage(string key, out string message)
```

В предыдущем примере применяется знакомый шаблон `Try*` в .NET. Для этого API существует два ссылочных аргумента: `key` и параметр `message`. У этого API есть следующие правила, относящиеся к значениям NULL этих аргументов.

- Вызывающие объекты не должны передавать `null` в качестве аргумента для `key`.
- Вызывающие объекты могут передавать переменную, значение которой равно `null`, в качестве аргумента для `message`.
- Если метод `TryGetMessage` возвращает `true`, значение `message` не равно NULL. Если возвращаемое значение равно `false,`, значение `message` (и его состояние со значением NULL) равно NULL.

Правило для `key` может быть выражено типом переменной: `key` должен быть ссылочным типом, не допускающим значения NULL. Параметр `message` является более сложным. Он допускает использование `null` в качестве аргумента, но гарантирует, что в случае успеха аргумент `out` не будет иметь значение NULL. В таких случаях требуется более широкое описание ожиданий.

Для выражения дополнительных сведений о состоянии NULL для переменных добавлено несколько атрибутов. Весь код, написанный до ввода ссылочных типов, допускающих значение NULL, в C# версии 8, *игнорировал допустимость значений NULL*. Это означает, что любая переменная ссылочного типа может принимать значение NULL, но проверки значений NULL не требуются. Но если код *допускает значения NULL*, эти правила меняются. Ссылочные типы никогда не должны быть значением `null`, а ссылочные типы, допускающие значения NULL, перед разыменованием должны проверяться на наличие `null`.

Правила для API-интерфейсов, по всей вероятности, более сложны, как было показано в сценарии `TryGetValue` API. Для многих API действуют более сложные правила в отношении того, когда переменные могут или не могут иметь значение `null`. В таких случаях для выражения этих правил используется один из следующих атрибутов.

- [AllowNull](xref:System.Diagnostics.CodeAnalysis.AllowNullAttribute). Входной аргумент, не допускающий значение NULL, может принимать значение NULL.
- [DisallowNull](xref:System.Diagnostics.CodeAnalysis.DisallowNullAttribute). Входной аргумент, допускающий значение NULL, никогда не должен принимать значение NULL.
- [MaybeNull](xref:System.Diagnostics.CodeAnalysis.MaybeNullAttribute). Возвращаемое значение, не допускающее значение NULL, может быть равно NULL.
- [NotNull](xref:System.Diagnostics.CodeAnalysis.NotNullAttribute). Возвращаемое значение, допускающее значение NULL, никогда не будет равно NULL.
- [MaybeNullWhen](xref:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute). Входной аргумент, не допускающий значение NULL, может иметь значение NULL, если метод возвращает указанное значение `bool`.
- [NotNullWhen](xref:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute). Входной аргумент, допускающий значение NULL, не будет иметь значение NULL, если метод возвращает указанное значение `bool`.
- [NotNullIfNotNull](xref:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute). Возвращаемое значение не равно NULL, если аргумент для указанного параметра не равен NULL.
- [DoesNotReturn](xref:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute). Метод никогда не возвращает значение. Другими словами, он всегда создает исключение.
- [DoesNotReturnIf](xref:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute). Этот метод никогда не возвращает значение, если связанный параметр `bool` имеет указанное значение.

Приведенные выше сведения лишь кратко описывают каждый атрибут. В каждом следующем разделе действия и значения атрибутов рассматриваются более подробно.

При добавлении этих атрибутов компилятор получает дополнительные сведения о правилах для API. Если вызывающий код компилируется в контексте, допускающем значение NULL, и вызывающие объекты нарушают эти правила, компилятор выведет соответствующие предупреждения. Эти атрибуты не используются для выполнения дополнительных проверок в имеющейся реализации.

## <a name="specify-preconditions-allownull-and-disallownull"></a>Указание предусловий: `AllowNull` и `DisallowNull`

Рассмотрим свойство для чтения и записи, которое никогда не возвращает `null`, так как имеет разумное значение по умолчанию. Вызывающие объекты передают `null` методу доступа set при задании ему этого значения по умолчанию. Например, рассмотрим систему обмена сообщениями, запрашивающую имя экрана в комнате чата. Если имя не указано, система создает случайное значение.

```csharp
public string ScreenName
{
   get => _screenName;
   set => _screenName = value ?? GenerateRandomScreenName();
}
private string _screenName;
```

При компиляции предыдущего кода в контексте, игнорирующем допустимость значения NULL, не возникает никаких проблем. После включения ссылочных типов, допускающих значения NULL, свойство `ScreenName` преобразуется в ссылку, не допускающую значение NULL. Это верно для метода доступа `get`: он никогда не возвращает `null`. Вызывающим объектам не нужно проверять возвращаемое свойство на наличие значения `null`. Но теперь при задании свойству значения `null` создается предупреждение. Чтобы продолжить поддержку этого типа кода, добавьте атрибут <xref:System.Diagnostics.CodeAnalysis.AllowNullAttribute?displayProperty=nameWithType> к свойству, как показано в следующем коде.

```csharp
[AllowNull]
public string ScreenName
{
   get => _screenName;
   set => _screenName = value ?? GenerateRandomScreenName();
}
private string _screenName = GenerateRandomScreenName();
```

Чтобы использовать этот и другие атрибуты, описанные в этой статье, может потребоваться добавить директиву `using` для пространства имен <xref:System.Diagnostics.CodeAnalysis>. Атрибут применяется к свойству,а не методу доступа `set`. Атрибут `AllowNull` указывает *предусловия* и применяется только к входным данным. Метод доступа `get` имеет возвращаемое значение, но у него нет входных аргументов. Таким образом, атрибут `AllowNull` применяется только к методу доступа `set`.

В предыдущем примере показано, что следует искать при добавлении атрибута `AllowNull` к аргументу.

1. Общий контракт для этой переменной заключается в том, что она не должна принимать значение `null`, поэтому нужен ссылочный тип, не допускающий значение NULL.
1. Существуют сценарии, когда выходная переменная может иметь значение `null`, однако они используются довольно редко.

Чаще всего этот атрибут будет необходим для свойств или аргументов `in`, `out` и `ref`. Атрибут `AllowNull` лучше всего применять в ситуации, когда переменная обычно имеет значение, отличное от NULL, но необходимо разрешить `null` в качестве предусловия.

Сравните этот вариант со сценариями использования `DisallowNull`: этот атрибут используется для указания того, что входная переменная ссылочного типа, допускающего значение NULL, не должна иметь значение `null`. Рассмотрим свойство, где `null` является значением по умолчанию, но клиенты могут задать для него только значение, отличное от NULL. Рассмотрим следующий код.

```csharp
public string ReviewComment
{
    get => _comment;
    set => _comment = value ?? throw new ArgumentNullException(nameof(value), "Cannot set to null");
}
string _comment;
```

Предыдущий код лучше всего демонстрирует ваше намерение выразить то, что атрибут `ReviewComment` может принимать значение `null`, но ему невозможно задать значение `null`. В коде, допускающем значения NULL, эту концепцию можно представить вызывающим объектам более четко с помощью <xref:System.Diagnostics.CodeAnalysis.DisallowNullAttribute?displayProperty=nameWithType>.

```csharp
[DisallowNull]
public string? ReviewComment
{
    get => _comment;
    set => _comment = value ?? throw new ArgumentNullException(nameof(value), "Cannot set to null");
}
string? _comment;
```

В контексте, допускающем значения NULL, метод доступа `ReviewComment` `get` может возвращать значение по умолчанию, равное `null`. Компилятор предупреждает, что перед доступом необходимо проверить это значение. Более того, он предупреждает вызывающие объекты о том, что это может быть `null`, им не следует явно задавать его равным `null`. Атрибут `DisallowNull` также задает *предварительное условие*, он не влияет на метод доступа `get`. Атрибут `DisallowNull` используется при отслеживании следующих моментов.

1. Переменная может принимать значение `null` в основных сценариях, часто при первом создании экземпляра.
1. Переменной не следует явно задавать значение `null`.

Эти ситуации распространены в коде, который изначально *игнорировал допустимость значений NULL*. Может быть так, что свойства объекта задаются в двух отдельных операциях инициализации. Может быть так, что некоторые свойства задаются только после завершения какой-либо асинхронной операции.

Атрибуты `AllowNull` и `DisallowNull` позволяют указать, что предусловия для переменных могут не соответствовать заметкам, допускающим значение NULL, для этих переменных. Они предоставляют более подробные сведения о характеристиках API. Эта информация помогает вызывающим объектам правильно использовать API. Помните, что для указания предусловий используются следующие атрибуты.

- [AllowNull](xref:System.Diagnostics.CodeAnalysis.AllowNullAttribute). Входной аргумент, не допускающий значение NULL, может принимать значение NULL.
- [DisallowNull](xref:System.Diagnostics.CodeAnalysis.DisallowNullAttribute). Входной аргумент, допускающий значение NULL, никогда не должен принимать значение NULL.

## <a name="specify-post-conditions-maybenull-and-notnull"></a>Указание постусловий: `MaybeNull` и `NotNull`

Предположим, у вас есть метод со следующей сигнатурой.

```csharp
public Customer FindCustomer(string lastName, string firstName)
```

Вероятно, вы написали такой метод для возвращения значения `null` в случае, если искомое имя не найдено. `null` четко указывает, что запись не найдена. В этом примере вы, вероятно, измените тип возвращаемого значения с `Customer` на `Customer?`. Объявление возвращаемого значения как ссылочного типа, допускающего значение NULL, четко указывает намерение этого API.

По причинам, описанным в разделе [Универсальные определения и допустимость значений NULL](../../nullable-migration-strategies.md#generic-definitions-and-nullability), этот метод не работает с универсальными методами. У вас может быть универсальный метод, который действует по аналогичному шаблону.

```csharp
public T Find<T>(IEnumerable<T> sequence, Func<T, bool> predicate)
```

Нельзя указать, что возвращаемое значение — `T?`. Если искомый элемент не найден, метод возвращает `null`. Так как вы не можете объявить тип возвращаемого значения `T?`, добавьте заметку `MaybeNull` к значению, возвращаемому методом.

```csharp
[return: MaybeNull]
public T Find<T>(IEnumerable<T> sequence, Func<T, bool> predicate)
```

Предыдущий код информирует вызывающие объекты о том, что подразумевается тип, не допускающий значение NULL, но возвращаемое значение на самом деле *может* быть равно NULL.  Используйте атрибут `MaybeNull`, если API должен быть типом, не допускающим значение NULL (как правило, параметром универсального типа), но могут быть случаи, когда возвращается `null`.

Можно также указать, что возвращаемое значение или аргумент `out` или `ref` не равны NULL, даже если тип является ссылочным типом, допускающим значение NULL. Рассмотрим метод, гарантирующий достаточный размер массива для хранения ряда элементов. Если у входного аргумента отсутствует необходимая емкость, подпрограмма выделит новый массив и скопирует в него все существующие элементы. Если входной аргумент имеет значение `null`, подсистема выделит новое хранилище. Если имеется достаточная емкость, подпрограмма не выполняет никаких действий.

```csharp
public void EnsureCapacity<T>(ref T[] storage, int size)
```

Эту подпрограмму можно вызвать следующим образом.

```csharp
// messages has the default value (null) when EnsureCapacity is called:
EnsureCapacity<string>(ref messages, 10);
// messages is not null.
EnsureCapacity<string>(messages, 50);
```

После включения ссылочных типов, допускающих значения NULL, необходимо убедиться, что предыдущий код компилируется без вывода предупреждений. Когда метод возвращает значение, аргумент `storage` гарантированно не будет равен NULL. Однако можно вызвать `EnsureCapacity` с пустой ссылкой. Можно сделать `storage` ссылочным типом, допускающим значение NULL, и добавить постусловие `NotNull` в объявление параметра.

```csharp
public void EnsureCapacity<T>([NotNull] ref T[]? storage, int size)
```

В предыдущем коде показано четкое выражение существующего контракта. Вызывающие объекты могут передавать переменную со значением `null`, но возвращаемое значение гарантированно никогда не будет равно NULL. Атрибут `NotNull` лучше всего подходит для аргументов `ref` и `out`, когда `null` может передаваться в качестве аргумента, но при возврате метода этот аргумент гарантированно не будет равен NULL.

Для указания безусловных постусловий используются следующие атрибуты.

- [MaybeNull](xref:System.Diagnostics.CodeAnalysis.MaybeNullAttribute). Возвращаемое значение, не допускающее значение NULL, может быть равно NULL.
- [NotNull](xref:System.Diagnostics.CodeAnalysis.NotNullAttribute). Возвращаемое значение, допускающее значение NULL, никогда не будет равно NULL.

## <a name="specify-conditional-post-conditions-notnullwhen-maybenullwhen-and-notnullifnotnull"></a>Указание условных постусловий: `NotNullWhen`, `MaybeNullWhen` и `NotNullIfNotNull`

Вам, скорее всего, известен метод <xref:System.String.IsNullOrEmpty(System.String)?DisplayProperty=nameWithType> `string`. Этот метод возвращает `true`, если аргумент имеет значение NULL или является пустой строкой. Вот форма проверки значений NULL. Если метод возвращает `false`, вызывающим объектам не требуется выполнять проверку значений NULL. Чтобы сделать такой метод методом, допускающим значения NULL, необходимо задать для аргумента ссылочный тип, допускающий значение NULL, и добавить атрибут `NotNullWhen`.

```csharp
bool IsNullOrEmpty([NotNullWhen(false)] string? value);
```

В этом случае компилятор знает, что любой код, в котором возвращаемое значение равно `false`, не должен проходить проверку значений NULL. Добавление атрибута означает, что `IsNullOrEmpty` выполняет необходимую проверку значений NULL: когда он возвращает `false`, входной аргумент не равен `null`.

```csharp
string? userInput = GetUserInput();
if (!string.IsNullOrEmpty(userInput))
{
   int messageLength = userInput.Length; // no null check needed.
}
// null check needed on userInput here.
```

Метод <xref:System.String.IsNullOrEmpty(System.String)?DisplayProperty=nameWithType> будет помечен для .NET Core 3.0, как показано выше. В вашей базе кода могут быть аналогичные методы, которые проверяют состояние объектов на значения NULL. Компилятор не распознает пользовательские методы проверки значений NULL, и вам потребуется добавить заметки самостоятельно. При добавлении атрибута статический анализ компилятора знает, когда тестируемая переменная прошла проверку на наличие значения NULL.

Другим применением этих атрибутов является шаблон `Try*`. Постусловия для переменных `ref` и `out` сообщаются через возвращаемое значение. Рассмотрим этот метод, показанный ранее.

```csharp
bool TryGetMessage(string key, out string message)
```

Предыдущий метод соответствует стандартному подходу .NET: возвращаемое значение указывает, было ли `message` задано найденное значение или задано значение по умолчанию, если сообщение не было найдено. Если метод возвращает `true`, значение `message` не равно NULL. В противном случае метод задает `message` значение NULL.

Этот принцип можно передать с помощью атрибута `NotNullWhen`. При обновлении сигнатуры для ссылочных типов, допускающих значение NULL, задайте `message` значение `string?` и добавьте атрибут.

```csharp
bool TryGetMessage(string key, [NotNullWhen(true)] out string? message)
```

В предыдущем примере, когда `TryGetMessage` возвращает `true`, известно, что значение `message` не будет равно NULL. Точно так же можно добавить заметки к аналогичным методам в базе кода: аргументы могут иметь значение `null` и известно, что они не будут равны NULL при возвращении методом значения `true`.

Кроме того, может потребоваться еще один, последний атрибут. Иногда состояние NULL возвращаемого значения зависит от состояния NULL одного входного аргумента или нескольких. Эти методы возвращают значение, отличное от NULL, если определенные входные аргументы не равны `null`. Чтобы правильно добавить заметки к этим методам, используйте атрибут `NotNullIfNotNull`. Рассмотрим следующий метод.

```csharp
string GetTopLevelDomainFromFullUrl(string url);
```

Если аргумент `url` не равен NULL, выходные данные не равны `null`. После включения ссылок, допускающих значение NULL, эта подпись работает правильно при условии, если API никогда не принимает входные данные со значением NULL. Однако если входные данные могут иметь значение NULL, то возвращаемое значение также может иметь значение NULL. Таким образом, сигнатуру можно заменить следующим кодом.

```csharp
string? GetTopLevelDomainFromFullUrl(string? url);
```

Это работает, но вызывающим объектам придется часто проводить дополнительные проверки `null`. Контракт заключается в том, что возвращаемое значение будет равно `null` только тогда, когда входной аргумент `url` имеет значение `null`. Чтобы выразить этот контракт, можно добавить заметку к этому методу, как показано в следующем коде.

```csharp
[return: NotNullIfNotNull("url")]
string? GetTopLevelDomainFromFullUrl(string? url);
```

Возвращаемое значение и аргумент снабжены заметкой `?`, указывающей, что каждый из них может быть равен `null`. Атрибут дополнительно уточняет, что возвращаемое значение не будет равно NULL, если аргумент `url` не принимает значение `null`.

Для указания условных постусловий используются следующие атрибуты.

- [MaybeNullWhen](xref:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute). Входной аргумент, не допускающий значение NULL, может иметь значение NULL, если метод возвращает указанное значение `bool`.
- [NotNullWhen](xref:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute). Входной аргумент, допускающий значение NULL, не будет иметь значение NULL, если метод возвращает указанное значение `bool`.
- [NotNullIfNotNull](xref:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute). Возвращаемое значение не равно NULL, если входной аргумент для указанного параметра не равен NULL.

## <a name="verify-unreachable-code"></a>Проверка недостижимого кода

Некоторые методы, как правило, это вспомогательные методы исключений или другие служебные методы, всегда завершают работу, вызывая исключение. Или вспомогательный метод может вызвать исключение на основе значения логического аргумента.

В первом случае можно добавить атрибут `DoesNotReturn` в объявление метода. Компилятор предлагает три способа. Во-первых, компилятор выдает предупреждение, если существует путь для выхода из метода без вызова исключения. Во-вторых, компилятор помечает любой код после вызова этого метода как *недостижимый* до тех пор, пока не будет обнаружено соответствующее предложение `catch`. В третьих, недостижимый код не влияет на состояния со значением NULL. Рассмотрим этот метод:

```csharp
[DoesNotReturn]
private void FailFast()
{
    throw new InvalidOperationException();
}

public void SetState(object containedField)
{
    if (!isInitialized)
    {
        FailFast();
    }

    // unreachable code:
    _field = containedField;
}
```

Во втором случае добавьте атрибут `DoesNotReturnIf` к логическому параметру метода. Предыдущий пример можно изменить следующим образом.

```csharp
private void FailFast([DoesNotReturnIf(false)] bool isValid)
{
    if (!isValid)
    {
        throw new InvalidOperationException();
    }
}

public void SetState(object containedField)
{
    FailFast(isInitialized);

    // unreachable code when "isInitialized" is false:
    _field = containedField;
}
```

## <a name="summary"></a>Сводка

[!INCLUDE [C# version alert](../../includes/csharp-version-alert.md)]

Добавление ссылочных типов, допускающих значения NULL, предоставляет исходный словарь для описания ожиданий API для переменных, которые могут иметь значение `null`. Дополнительные атрибуты позволяют более подробно описывать состояние NULL для переменных в качестве предусловий и постусловий. Эти атрибуты более четко описывают ожидания и обеспечивают более эффективную работу специалистов, использующих ваши API.

При обновлении библиотек для контекста, допускающего значение NULL, добавьте эти атрибуты, чтобы пользователи могли правильно использовать ваши API. С помощью этих атрибутов вы можете полностью описывать состояние NULL входных аргументов и возвращаемых значений.

- [AllowNull](xref:System.Diagnostics.CodeAnalysis.AllowNullAttribute). Входной аргумент, не допускающий значение NULL, может принимать значение NULL.
- [DisallowNull](xref:System.Diagnostics.CodeAnalysis.DisallowNullAttribute). Входной аргумент, допускающий значение NULL, никогда не должен принимать значение NULL.
- [MaybeNull](xref:System.Diagnostics.CodeAnalysis.MaybeNullAttribute). Возвращаемое значение, не допускающее значение NULL, может быть равно NULL.
- [NotNull](xref:System.Diagnostics.CodeAnalysis.NotNullAttribute). Возвращаемое значение, допускающее значение NULL, никогда не будет равно NULL.
- [MaybeNullWhen](xref:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute). Входной аргумент, не допускающий значение NULL, может иметь значение NULL, если метод возвращает указанное значение `bool`.
- [NotNullWhen](xref:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute). Входной аргумент, допускающий значение NULL, не будет иметь значение NULL, если метод возвращает указанное значение `bool`.
- [NotNullIfNotNull](xref:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute). Возвращаемое значение не равно NULL, если входной аргумент для указанного параметра не равен NULL.
- [DoesNotReturn](xref:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute). Метод никогда не возвращает значение. Другими словами, он всегда создает исключение.
- [DoesNotReturnIf](xref:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute). Этот метод никогда не возвращает значение, если связанный параметр `bool` имеет указанное значение.
