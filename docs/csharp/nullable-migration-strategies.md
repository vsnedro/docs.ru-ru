---
title: Обновление базы кода для использования ссылочных типов, допускающих значения null
description: Выбор оптимальной стратегии обновления базы кода для использования ссылочных типов, допускающих значения null.
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: ab0970247c7e3f3c20d7fdb40ef035c4ba1d8b01
ms.sourcegitcommit: 30e9e11dfd90112b8eec6406186ba3533f21eba1
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/21/2020
ms.locfileid: "97866826"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a>Обновление библиотек для использования ссылочных типов, допускающих значения null, и передача правил использования значений null в вызывающие объекты

Добавление [ссылочных типов, допускающих значения null,](nullable-references.md) означает, что для каждой переменной можно объявить, является ли значение `null` допустимым или ожидаемым. Кроме того, можно применить ряд атрибутов: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen` и `NotNullIfNotNull`, чтобы полностью описать состояния значения null для аргументов и возвращаемых значений. Это обеспечивает высокое удобство при написании кода. В ситуациях, когда переменной, не допускающей значение null, может быть присвоено значение `null`, появляются предупреждения. Вы получите предупреждение, если переменная, допускающая значение null, не проверяется на значение null перед разыменованием. Обновление библиотек может занять некоторое время, но результат того стоит. Чем больше информации вы предоставите компилятору о том, *когда* разрешены или запрещены значения `null`, тем полезнее будут предупреждения для пользователей вашего API. Начнем со знакомого примера. Представьте, что библиотека содержит следующий API для получения строки ресурса.

```csharp
bool TryGetMessage(string key, out string message)
```

В предыдущем примере применяется знакомый шаблон `Try*` в .NET. Для этого API существует два ссылочных аргумента: `key` и параметр `message`. У этого API есть следующие правила, относящиеся к значениям NULL этих аргументов.

- Вызывающие объекты не должны передавать `null` в качестве аргумента для `key`.
- Вызывающие объекты могут передавать переменную, значение которой равно `null`, в качестве аргумента для `message`.
- Если метод `TryGetMessage` возвращает `true`, значение `message` не равно NULL. Если возвращаемое значение равно `false,`, значение `message` (и его состояние со значением NULL) равно NULL.

Правило для `key` может быть полностью выражено типом переменной: `key` должен быть ссылочным типом, не допускающим значения null. Параметр `message` является более сложным. Он допускает использование `null` в качестве аргумента, но гарантирует, что в случае успеха аргумент `out` не будет иметь значение NULL. В таких случаях требуется более широкое описание ожиданий.

Обновление библиотеки для использования ссылочных типов, допускающих значение null, требует больше, чем просто добавления `?` к некоторым переменным и именам типов. В предыдущем примере показано, что необходимо изучить API и учесть свои ожидания для каждого входного аргумента. Учтите гарантии для возвращаемого значения и любых аргументов `out` или `ref` при возврате значения методом. Затем сообщите эти правила компилятору, и компилятор будет выдавать предупреждения, когда вызывающие объекты не соблюдают эти правила.

Эта работа занимает некоторое время. Начнем со стратегий, позволяющих библиотеке или приложению работать со значениями null, при этом соблюдая баланс других требований. Вы узнаете, как сбалансировать текущую разработку, разрешив ссылочные типы, допускающие значения null. Вы узнаете о проблемах, связанных с определением универсальных типов. Вы узнаете, как применять атрибуты для описания предварительных и последующих условий для отдельных API.

## <a name="choose-a-strategy-for-nullable-reference-types"></a>Выбор стратегии для ссылочных типов, допускающих значения null

Первый вариант заключается во включении или отключении ссылочных типов, допускающих значения null, по умолчанию. Существует две стратегии.

- Включить ссылочные типы, допускающие значение null, для всего проекта и отключить их в коде, который к ним не готов.
- Включить ссылочные типы, допускающие значение null, только для кода, аннотированного для ссылочных типов, допускающих значение null.

Первая стратегия лучше всего подходит, когда помимо обновления библиотеки для ссылочных типов, допускающих значение null, вы также добавляете в нее другие функции. Все новые разработки поддерживают значение null. При обновлении существующего кода в этих классах включаются ссылочные типы, допускающие значения NULL.

В рамках первой стратегии необходимо выполнить следующие действия.

1. Включить ссылочные типы, допускающие значение null, для всего проекта, добавив элемент `<Nullable>enable</Nullable>` в файлы *csproj*.
1. Добавить прагму `#nullable disable` в каждый исходный файл в проекте.
1. Работая с каждым файлом, удалите эту прагму и устраните все предупреждения.

Первая стратегия предполагает наличие подготовительной работы по добавлению прагмы в каждый файл. Преимущество заключается в том, что для каждого нового файла кода, добавленного в проект, будет разрешено значение null. Любая новая работа будет поддерживать значения null; необходимо будет обновить только существующий код.

Вторая стратегия работает лучше, если библиотека является стабильной, и основной задачей разработки является внедрение ссылочных типов, допускающих значение null. Ссылочные типы, допускающие значение null, включаются по мере аннотирования API. По завершении работы ссылочные типы, допускающие значение null, включаются для всего проекта.

В рамках второй стратегии необходимо выполнить следующие действия.

1. Добавить прагму `#nullable enable` в файл, в котором необходимо включить поддержку значений null.
1. Устранить все предупреждения.
1. Продолжать выполнение первых двух шагов, пока значения null не будет поддерживать вся библиотека.
1. Включить типы, допускающие значение null, для всего проекта, добавив элемент `<Nullable>enable</Nullable>` в файлы *csproj*.
1. Удалить прагмы `#nullable enable`, так как они больше не нужны.

Вторая стратегия требует меньше подготовительной работы. Компромисс заключается в том, что при создании нового файла в первую очередь необходимо добавить прагму и сделать его поддерживающим значение null. Если кто-то из разработчиков вашей команды забудет это сделать, новый код перейдет в разряд невыполненной работы по включению во всем коде поддержки значений null.

Выбор стратегии зависит от объема активной разработки в проекте. Чем более проект зрелый и стабильный, тем лучше работает вторая стратегия. Чем больше возможностей находится в разработке, тем лучше работает первая стратегия.

> [!IMPORTANT]
> Глобальный контекст, допускающий значения NULL, не применяется для созданных файлов кода. В любом случае контекст, допускающий значение NULL, *отключен* для любого исходного файла, помеченного как созданный. Это означает, что все интерфейсы API в создаваемых файлах не заносятся в заметки. Существует четыре способа пометки файла как созданного:
>
> 1. В файле. editorconfig укажите `generated_code = true` в разделе, который применяется к этому файлу.
> 1. Вставьте `<auto-generated>` или `<auto-generated/>` в комментарий в верхней части файла. Он может находиться в любой строке комментария, однако блок комментариев должен быть первым элементом в файле.
> 1. Имя файла следует начинать с *TemporaryGeneratedFile_*
> 1. В конце имени файла следует указать *.designer.cs*, *.generated.cs*, *.g.cs* или *.g.i.cs*.
>
> Генераторы могут явно использовать директиву препроцессора [`#nullable`](language-reference/preprocessor-directives/preprocessor-nullable.md).

## <a name="should-nullable-warnings-introduce-breaking-changes"></a>Приводят ли предупреждения о значениях null к внесению критических изменений?

До включения ссылочных типов, допускающих значения null, переменные считаются *игнорирующими значения null*. После включения ссылочных типов, допускающих значения null, все эти переменные станут *не допускающими значения null*. Если эти переменные не инициализируются значениями, отличными от null, компилятор выдаст предупреждение.

Другой вероятный источник предупреждений — возвращаемое значение, если оно не было инициализировано.

Первым шагом в исправлении предупреждений компилятора является добавление заметок `?` к параметрам и возвращаемым типам, чтобы указать, когда аргументы или возвращаемые значения могут иметь значение null. Если ссылочные переменные не должны иметь значение null, исходное объявление будет правильным. При выполнении этой задачи ваша цель заключается не только в устранении предупреждений. Более важная задача заключается в том, чтобы компилятор понял смысл возможных значений null. Изучив предупреждения, вы подойдете к следующему важному решению в отношении своей библиотеки. Вы хотите изменить сигнатуры API, чтобы более четко сообщить намерения разработчика? Улучшенная сигнатура API для метода `TryGetMessage`, изученного ранее, может выглядеть следующим образом:

```csharp
string? TryGetMessage(string key);
```

Возвращаемое значение указывает на успех или сбой и содержит значение, если значение было найдено. Во многих случаях изменение сигнатур API может улучшить способ передачи значений null.

Однако для общедоступных библиотек или библиотек с большой пользовательской базой вы, вероятно, не захотите вносить изменения в сигнатуры API. В таких случаях и других распространенных шаблонах можно применять атрибуты для более четкого определения того, когда аргумент или возвращаемое значение могут иметь значение `null`. Независимо от того, рассматриваете ли вы изменение поверхности API или нет, скорее всего, вы обнаружите, что одних аннотаций типа недостаточно для описания значений `null` для аргументов и возвращаемых значений. В этих случаях можно применять атрибуты для более четкого описания API.

## <a name="attributes-extend-type-annotations"></a>Атрибуты расширяют аннотации типов

Для выражения дополнительных сведений о состоянии NULL для переменных добавлено несколько атрибутов. Весь код, написанный до ввода ссылочных типов, допускающих значение NULL, в C# версии 8, *игнорировал допустимость значений NULL*. Это означает, что любая переменная ссылочного типа может принимать значение NULL, но проверки значений NULL не требуются. Но если код *допускает значения NULL*, эти правила меняются. Ссылочные типы никогда не должны быть значением `null`, а ссылочные типы, допускающие значения NULL, перед разыменованием должны проверяться на наличие `null`.

Правила для API-интерфейсов, по всей вероятности, более сложны, как было показано в сценарии `TryGetValue` API. Для многих API действуют более сложные правила в отношении того, когда переменные могут или не могут иметь значение `null`. В таких случаях для выражения этих правил используются атрибуты. Атрибуты, описывающие семантику API, см. в статье, посвященной [атрибутам, влияющим на анализ значений null](./language-reference/attributes/nullable-analysis.md).

## <a name="generic-definitions-and-nullability"></a>Универсальные определения и допустимость значений null

Правильная передача состояния null универсальных типов и универсальных методов требует особой осторожности. Особое внимание уделяется тому факту, что тип значения, допускающий значение null, и ссылочный тип, допускающий значения null, являются фундаментально разными. `int?` является синонимом `Nullable<int>`, тогда как `string?` является `string` с атрибутом, добавленным компилятором. В результате компилятор не может создать правильный код для `T?`, не зная, является ли `T` `class` или `struct`.

Этот факт не означает, что нельзя использовать тип, допускающий значение null (тип значения или ссылочный тип), в качестве аргумента типа для закрытого универсального типа. `List<string?>` и `List<int?>` являются допустимыми экземплярами `List<T>`.

В действительности это означает, что нельзя использовать `T?` в объявлении универсального класса или метода без ограничений. Например, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> не будет изменен для возврата `T?`. Это ограничение можно преодолеть, добавив ограничение `struct` или `class`. При указании любого из этих ограничений компилятор будет знать, как создавать код для `T` и `T?`.

Может потребоваться ограничить типы, используемые для аргумента универсального типа, типами, не допускающими значения null. Это можно сделать, добавив ограничение `notnull` для этого аргумента типа. При применении этого ограничения аргумент типа должен быть типом, не допускающим значение null.

## <a name="late-initialized-properties-data-transfer-objects-and-nullability"></a>Свойства с поздней инициализацией, объекты передачи данных и допустимость значений null

Указание допустимости значений null для свойств с поздней инициализацией, то есть задаваемых после создания, может потребовать особого внимания, чтобы класс продолжал правильно выражать первоначальное намерение разработчика.

Типы, содержащие свойства с поздней инициализацией, такие как объекты передачи данных (DTO), часто создаются внешней библиотекой, например базой данных ORM (реляционный сопоставитель объектов), десериализатором или каким-либо другим компонентом, который автоматически заполняет свойства из другого источника.

Перед включением ссылочных типов, допускающих значение null, рассмотрим следующий класс DTO, который представляет учащегося:

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string VehicleRegistration { get; set; }
}
```

Цель разработки (указанная в этом случае атрибутом `Required`) предполагает, что в этой системе свойства `FirstName` и `LastName` являются **обязательными** и, следовательно, не могут иметь значение null.

Свойство `VehicleRegistration` **не является обязательным**, поэтому может иметь значение null.

При включении ссылочных типов, допускающих значения null, необходимо указать, какие свойства в DTO могут допускать значение null, в соответствии с исходным намерением:

```csharp
class Student
{
    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

В этом примере в объекте DTO единственным свойством, которое может иметь значение null, является ``VehicleRegistration``.

Однако компилятор создает предупреждения `CS8618` как для `FirstName`, так и для `LastName`, указывая, что свойства, не допускающие значения null, не инициализированы.

Существует три варианта разрешения предупреждений компилятора таким образом, чтобы сохранить исходное намерение. Все эти варианты являются допустимыми, поэтому можно выбрать тот, который лучше подходит к стилю написания кода и требованиям к разработке.

### <a name="initialize-in-the-constructor"></a>Инициализация в конструкторе

Идеальным способом устранения неинициализированных предупреждений является инициализация свойств в конструкторе:

```csharp
class Student
{
    public Student(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    [Required]
    public string FirstName { get; set; }

    [Required]
    public string LastName { get; set; }

    public string? VehicleRegistration { get; set; }
}
```

Этот подход работает только в том случае, если библиотека, используемая для создания экземпляра класса, поддерживает передачу параметров в конструктор.

Библиотека может поддерживать передачу *некоторых* свойств в конструктор, но не все. Например, EF Core поддерживает [привязку конструктора](/ef/core/modeling/constructors) для обычных свойств столбца, но не для свойств навигации.

Ознакомьтесь с документацией по библиотеке, которая создает экземпляр класса, чтобы понять, в какой степени она поддерживает привязку конструктора.

### <a name="property-with-nullable-backing-field"></a>Свойство с резервным полем, допускающим значение null

Если привязка конструктора вам не подходит, одним из способов решения этой проблемы является наличие свойства, не допускающего значения null, с резервным полем, допускающим значение null.

```csharp
private string? _firstName;

[Required]
public string FirstName
{
    set => _firstName = value;
    get => _firstName
           ?? throw new InvalidOperationException("Uninitialized " + nameof(FirstName))
}
```

В этом сценарии, если доступ к свойству `FirstName` осуществляется до инициализации, код создает исключение `InvalidOperationException`, так как контракт API используется неправильно.

Учтите, что для некоторых библиотек могут иметься особые соображения при использовании резервных полей. Например, в EF Core может потребоваться настройка для правильного использования [резервных полей](/ef/core/modeling/backing-field).

### <a name="initialize-the-property-to-null"></a>Инициализация свойства значением null

В качестве более краткой альтернативы использованию резервного поля, допускающего значение null, или если библиотека, которая создает экземпляр класса, несовместима с этим подходом, можно напрямую инициализировать свойство значением `null` с помощью оператора, разрешающего значение null (`!`):

```csharp
[Required]
public string FirstName { get; set; } = null!;

[Required]
public string LastName { get; set; } = null!;

public string? VehicleRegistration { get; set; }
```

Фактическое значение null во время выполнения никогда не проявится, за исключением случаев ошибок программирования, когда обращение к свойству будет происходить до того, как оно будет правильно инициализировано.

## <a name="see-also"></a>См. также раздел

- [Перенос существующей базы кода на ссылки, допускающие значение NULL](tutorials/upgrade-to-nullable-references.md)
- [Работа со ссылочными типами, допускающими значение null в EF Core](/ef/core/miscellaneous/nullable-reference-types)
