---
title: Руководство по программированию на C#. Объекты
description: Для определения типов объектов в C# используется определение класса или структуры. В объектно-ориентированном языке, таком как C#, программа состоит из динамически взаимодействующих объектов.
ms.date: 07/20/2015
helpviewer_keywords:
- objects [C#], about objects
- variables [C#]
ms.assetid: af4a5230-fbf3-4eea-95e1-8b883c2f845c
ms.openlocfilehash: b54db325c568dec702e4e50c3c265286662092fe
ms.sourcegitcommit: 3d84eac0818099c9949035feb96bbe0346358504
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/21/2020
ms.locfileid: "86864765"
---
# <a name="objects-c-programming-guide"></a><span data-ttu-id="3277b-104">Объекты (Руководство по программированию на C#)</span><span class="sxs-lookup"><span data-stu-id="3277b-104">Objects (C# Programming Guide)</span></span>
<span data-ttu-id="3277b-105">Определение класса или структуры подобно чертежу, на котором указаны действия, выполняемые типом.</span><span class="sxs-lookup"><span data-stu-id="3277b-105">A class or struct definition is like a blueprint that specifies what the type can do.</span></span> <span data-ttu-id="3277b-106">В сущности, объект является блоком памяти, выделенной и настроенной в соответствии с чертежом.</span><span class="sxs-lookup"><span data-stu-id="3277b-106">An object is basically a block of memory that has been allocated and configured according to the blueprint.</span></span> <span data-ttu-id="3277b-107">Программа может создать множество объектов одного класса.</span><span class="sxs-lookup"><span data-stu-id="3277b-107">A program may create many objects of the same class.</span></span> <span data-ttu-id="3277b-108">Объекты также называют экземплярами. Они могут храниться либо в именованной переменной, либо в массиве или коллекции.</span><span class="sxs-lookup"><span data-stu-id="3277b-108">Objects are also called instances, and they can be stored in either a named variable or in an array or collection.</span></span> <span data-ttu-id="3277b-109">Клиентский код — это код, использующий эти переменные для вызова методов и доступа к открытым свойствам объекта.</span><span class="sxs-lookup"><span data-stu-id="3277b-109">Client code is the code that uses these variables to call the methods and access the public properties of the object.</span></span> <span data-ttu-id="3277b-110">В объектно-ориентированном языке, таком как C#, стандартная программа состоит из нескольких динамически взаимодействующих объектов.</span><span class="sxs-lookup"><span data-stu-id="3277b-110">In an object-oriented language such as C#, a typical program consists of multiple objects interacting dynamically.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3277b-111">Поведение статических типов отличается от описанного здесь поведения.</span><span class="sxs-lookup"><span data-stu-id="3277b-111">Static types behave differently than what is described here.</span></span> <span data-ttu-id="3277b-112">Дополнительные сведения см. в статье [Статические классы и члены статических классов](./static-classes-and-static-class-members.md).</span><span class="sxs-lookup"><span data-stu-id="3277b-112">For more information, see [Static Classes and Static Class Members](./static-classes-and-static-class-members.md).</span></span>
  
## <a name="struct-instances-vs-class-instances"></a><span data-ttu-id="3277b-113">Экземпляры структуры и Экземпляры классов</span><span class="sxs-lookup"><span data-stu-id="3277b-113">Struct Instances vs. Class Instances</span></span>  
 <span data-ttu-id="3277b-114">Так как классы являются ссылочными типами, в переменной объекта класса хранится ссылка на адрес объекта в управляемой куче.</span><span class="sxs-lookup"><span data-stu-id="3277b-114">Because classes are reference types, a variable of a class object holds a reference to the address of the object on the managed heap.</span></span> <span data-ttu-id="3277b-115">Если первому объекту назначен второй объект того же типа, обе переменные ссылаются на объект, расположенный по данному адресу.</span><span class="sxs-lookup"><span data-stu-id="3277b-115">If a second object of the same type is assigned to the first object, then both variables refer to the object at that address.</span></span> <span data-ttu-id="3277b-116">Эта особенность обсуждается более подробно далее в этом разделе.</span><span class="sxs-lookup"><span data-stu-id="3277b-116">This point is discussed in more detail later in this topic.</span></span>  
  
 <span data-ttu-id="3277b-117">Экземпляры классов создаются с помощью [оператора new](../../language-reference/operators/new-operator.md).</span><span class="sxs-lookup"><span data-stu-id="3277b-117">Instances of classes are created by using the [new operator](../../language-reference/operators/new-operator.md).</span></span> <span data-ttu-id="3277b-118">В приведенном ниже примере `Person` является типом, а `person1` и `person 2` — экземплярами или объектами этого типа.</span><span class="sxs-lookup"><span data-stu-id="3277b-118">In the following example, `Person` is the type and `person1` and `person 2` are instances, or objects, of that type.</span></span>  
  
 [!code-csharp[csProgGuideStatements#30](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#30)]  
  
 <span data-ttu-id="3277b-119">Так как структуры являются типами значений, в переменной объекта структуры хранится копия всего объекта.</span><span class="sxs-lookup"><span data-stu-id="3277b-119">Because structs are value types, a variable of a struct object holds a copy of the entire object.</span></span> <span data-ttu-id="3277b-120">Экземпляры структур также можно создавать с помощью оператора `new`, однако он не является обязательным, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="3277b-120">Instances of structs can also be created by using the `new` operator, but this is not required, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#31](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#31)]  
  
 <span data-ttu-id="3277b-121">Память для `p1` и `p2` выделена в стеке потока.</span><span class="sxs-lookup"><span data-stu-id="3277b-121">The memory for both `p1` and `p2` is allocated on the thread stack.</span></span> <span data-ttu-id="3277b-122">Эта память освобождается вместе с типом или методом, в котором она объявляется.</span><span class="sxs-lookup"><span data-stu-id="3277b-122">That memory is reclaimed along with the type or method in which it is declared.</span></span> <span data-ttu-id="3277b-123">Эта одна из причин того, почему структуры копируются при присваивании.</span><span class="sxs-lookup"><span data-stu-id="3277b-123">This is one reason why structs are copied on assignment.</span></span> <span data-ttu-id="3277b-124">Напротив, при выходе всех ссылок на объект из области действия среда CLR автоматически освобождает память (выполняет сборку мусора), выделенную для экземпляра класса.</span><span class="sxs-lookup"><span data-stu-id="3277b-124">By contrast, the memory that is allocated for a class instance is automatically reclaimed (garbage collected) by the common language runtime when all references to the object have gone out of scope.</span></span> <span data-ttu-id="3277b-125">Возможность детерминированного уничтожения объекта класса, имеющаяся в C++, в данном случае отсутствует.</span><span class="sxs-lookup"><span data-stu-id="3277b-125">It is not possible to deterministically destroy a class object like you can in C++.</span></span> <span data-ttu-id="3277b-126">Дополнительные сведения о сборке мусора в .NET см. в статье [Сборка мусора](../../../standard/garbage-collection/index.md).</span><span class="sxs-lookup"><span data-stu-id="3277b-126">For more information about garbage collection in .NET, see [Garbage Collection](../../../standard/garbage-collection/index.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3277b-127">В среде CLR процесс выделения и освобождения памяти в управляемой куче значительно оптимизирован.</span><span class="sxs-lookup"><span data-stu-id="3277b-127">The allocation and deallocation of memory on the managed heap is highly optimized in the common language runtime.</span></span> <span data-ttu-id="3277b-128">В большинстве случаев нет существенной разницы в затратах производительности на выделение экземпляра класса в куче и выделение экземпляра структуры в стеке.</span><span class="sxs-lookup"><span data-stu-id="3277b-128">In most cases there is no significant difference in the performance cost of allocating a class instance on the heap versus allocating a struct instance on the stack.</span></span>
  
## <a name="object-identity-vs-value-equality"></a><span data-ttu-id="3277b-129">Идентификация объектов и равенство значений</span><span class="sxs-lookup"><span data-stu-id="3277b-129">Object Identity vs. Value Equality</span></span>  
 <span data-ttu-id="3277b-130">Сравнивая два объекта на предмет равенства, сначала необходимо определить, нужно ли узнать, представляют ли две переменные один объект в памяти или значения одного или нескольких их полей являются равными.</span><span class="sxs-lookup"><span data-stu-id="3277b-130">When you compare two objects for equality, you must first distinguish whether you want to know whether the two variables represent the same object in memory, or whether the values of one or more of their fields are equivalent.</span></span> <span data-ttu-id="3277b-131">Если вы планируете сравнить значения, следует решить, являются ли объекты экземплярами типов значений (структурами) или ссылочными типами (классами, делегатами, массивами).</span><span class="sxs-lookup"><span data-stu-id="3277b-131">If you are intending to compare values, you must consider whether the objects are instances of value types (structs) or reference types (classes, delegates, arrays).</span></span>  
  
- <span data-ttu-id="3277b-132">Чтобы определить, ссылаются ли два экземпляра класса на одно расположение в памяти (то есть имеют одинаковый *идентификатор*), воспользуйтесь статическим методом <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="3277b-132">To determine whether two class instances refer to the same location in memory (which means that they have the same *identity*), use the static <xref:System.Object.Equals%2A> method.</span></span> <span data-ttu-id="3277b-133">(<xref:System.Object?displayProperty=nameWithType> является неявным базовым классом для всех типов значений и ссылочных типов, включая структуры и классы, определенные пользователем.)</span><span class="sxs-lookup"><span data-stu-id="3277b-133">(<xref:System.Object?displayProperty=nameWithType> is the implicit base class for all value types and reference types, including user-defined structs and classes.)</span></span>  
  
- <span data-ttu-id="3277b-134">Чтобы определить, имеют ли поля экземпляра в двух экземплярах структуры одинаковые значения, воспользуйтесь методом <xref:System.ValueType.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3277b-134">To determine whether the instance fields in two struct instances have the same values, use the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3277b-135">Так как все структуры неявно наследуются от <xref:System.ValueType?displayProperty=nameWithType>, метод можно вызвать непосредственно в объекте, как показано в следующем примере:</span><span class="sxs-lookup"><span data-stu-id="3277b-135">Because all structs implicitly inherit from <xref:System.ValueType?displayProperty=nameWithType>, you call the method directly on your object as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideStatements#32](~/samples/snippets/csharp/VS_Snippets_VBCSharp/csProgGuideStatements/CS/Statements.cs#32)]  
  
 <span data-ttu-id="3277b-136">В реализации <xref:System.ValueType?displayProperty=nameWithType>`Equals` используется отражение, так как необходимо определить поля, имеющиеся в любой структуре.</span><span class="sxs-lookup"><span data-stu-id="3277b-136">The <xref:System.ValueType?displayProperty=nameWithType> implementation of `Equals` uses reflection because it must be able to determine what the fields are in any struct.</span></span> <span data-ttu-id="3277b-137">При создании собственных структур переопределите метод `Equals` для предоставления эффективного алгоритма равенства, соответствующего вашему типу.</span><span class="sxs-lookup"><span data-stu-id="3277b-137">When creating your own structs, override the `Equals` method to provide an efficient equality algorithm that is specific to your type.</span></span>  
  
- <span data-ttu-id="3277b-138">Чтобы определить, равны ли значения полей в двух экземплярах класса, можно воспользоваться методом <xref:System.Object.Equals%2A> или [оператором ==](../../language-reference/operators/equality-operators.md#equality-operator-).</span><span class="sxs-lookup"><span data-stu-id="3277b-138">To determine whether the values of the fields in two class instances are equal, you might be able to use the <xref:System.Object.Equals%2A> method or the [== operator](../../language-reference/operators/equality-operators.md#equality-operator-).</span></span> <span data-ttu-id="3277b-139">Однако их следует использовать, только если они переопределены или перегружены классом с целью предоставления пользовательского определение равенства для объектов этого типа.</span><span class="sxs-lookup"><span data-stu-id="3277b-139">However, only use them if the class has overridden or overloaded them to provide a custom definition of what "equality" means for objects of that type.</span></span> <span data-ttu-id="3277b-140">Класс может также реализовывать интерфейс <xref:System.IEquatable%601> или интерфейс <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="3277b-140">The class might also implement the <xref:System.IEquatable%601> interface or the <xref:System.Collections.Generic.IEqualityComparer%601> interface.</span></span> <span data-ttu-id="3277b-141">Оба интерфейса предоставляют методы, которые можно использовать для проверки равенства значений.</span><span class="sxs-lookup"><span data-stu-id="3277b-141">Both interfaces provide methods that can be used to test value equality.</span></span> <span data-ttu-id="3277b-142">При создании собственных классов, переопределяющих `Equals`, обязательно выполните инструкции из руководства по [определению равенства значений для типа ](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) и <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3277b-142">When designing your own classes that override `Equals`, make sure to follow the guidelines stated in [How to define value equality for a type](../statements-expressions-operators/how-to-define-value-equality-for-a-type.md) and <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span>
  
## <a name="related-sections"></a><span data-ttu-id="3277b-143">Связанные разделы</span><span class="sxs-lookup"><span data-stu-id="3277b-143">Related Sections</span></span>  
 <span data-ttu-id="3277b-144">Дополнительные сведения:</span><span class="sxs-lookup"><span data-stu-id="3277b-144">For more information:</span></span>  
  
- [<span data-ttu-id="3277b-145">Классы</span><span class="sxs-lookup"><span data-stu-id="3277b-145">Classes</span></span>](./classes.md)  
  
- [<span data-ttu-id="3277b-146">Конструкторы</span><span class="sxs-lookup"><span data-stu-id="3277b-146">Constructors</span></span>](./constructors.md)  
  
- [<span data-ttu-id="3277b-147">Методы завершения</span><span class="sxs-lookup"><span data-stu-id="3277b-147">Finalizers</span></span>](./destructors.md)  
  
- [<span data-ttu-id="3277b-148">События</span><span class="sxs-lookup"><span data-stu-id="3277b-148">Events</span></span>](../events/index.md)  
  
## <a name="see-also"></a><span data-ttu-id="3277b-149">См. также</span><span class="sxs-lookup"><span data-stu-id="3277b-149">See also</span></span>

- [<span data-ttu-id="3277b-150">Руководство по программированию на C#</span><span class="sxs-lookup"><span data-stu-id="3277b-150">C# Programming Guide</span></span>](../index.md)
- [<span data-ttu-id="3277b-151">object</span><span class="sxs-lookup"><span data-stu-id="3277b-151">object</span></span>](../../language-reference/builtin-types/reference-types.md)
- [<span data-ttu-id="3277b-152">Наследование</span><span class="sxs-lookup"><span data-stu-id="3277b-152">Inheritance</span></span>](./inheritance.md)
- [<span data-ttu-id="3277b-153">class</span><span class="sxs-lookup"><span data-stu-id="3277b-153">class</span></span>](../../language-reference/keywords/class.md)
- [<span data-ttu-id="3277b-154">Типы структур</span><span class="sxs-lookup"><span data-stu-id="3277b-154">Structure types</span></span>](../../language-reference/builtin-types/struct.md)
- [<span data-ttu-id="3277b-155">Оператор new</span><span class="sxs-lookup"><span data-stu-id="3277b-155">new Operator</span></span>](../../language-reference/operators/new-operator.md)
- [<span data-ttu-id="3277b-156">Система общих типов CTS</span><span class="sxs-lookup"><span data-stu-id="3277b-156">Common Type System</span></span>](../../../standard/base-types/common-type-system.md)
