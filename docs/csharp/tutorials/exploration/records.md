---
title: Использование типов записей — учебник по C#
description: Сведения об использовании типов записей, построении иерархий записей, а также о том, когда следует выбирать записи вместо классов.
ms.date: 11/12/2020
ms.openlocfilehash: 8a2cb6966ab4f93432723fd6f82618efa86b26aa
ms.sourcegitcommit: 34968a61e9bac0f6be23ed6ffb837f52d2390c85
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/17/2020
ms.locfileid: "94688561"
---
# <a name="create-record-types"></a>Создание типов записей

В C# 9 появились *записи* — новый тип ссылки, который можно создать вместо классов или структур. Записи отличаются от классов тем, что типы записей используют *равенство на основе значений*. Две переменные типа записи равны, если определения типов записей идентичны и если для каждого поля значения в обеих записях равны. Две переменные типа класса равны, если объекты, на которые они ссылаются, относятся к одному и тому же типу класса, а переменные ссылаются на один и тот же объект. Равенство на основе значений подразумевает другие полезные возможности. Компилятор создает многие из этих элементов при объявлении `record` вместо `class`.

Из этого руководства вы узнаете, как выполнять следующие задачи:

> [!div class="checklist"]
>
> - Решите, следует ли объявлять `class` или `record`.
> - Объявите типы записей и типы позиционных записей.
> - Замените методы на созданные компилятором методы в записях.

## <a name="prerequisites"></a>Предварительные условия

Вам нужно настроить компьютер для выполнения .NET 5 или более поздней версии, включая компилятор C# 9.0 или более поздней версии. Компилятор C# 9.0 доступен начиная с [версии 16.8 Visual Studio 2019](https://visualstudio.microsoft.com/vs) или [пакета SDK для .NET Core 5.0](https://dotnet.microsoft.com/download).

## <a name="characteristics-of-records"></a>Характеристики записей

Вы определяете *запись*, объявляя тип с помощью ключевого слова `record` вместо ключевого слова `class` или `struct`. Запись является ссылочным типом и соответствует семантике равенства на основе значений. Чтобы обеспечить такую семантику, компилятор создает несколько методов для типа записи:

- Переопределение <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.
- Виртуальный метод `Equals`, параметр которого является типом записи.
- Переопределение <xref:System.Object.GetHashCode?displayProperty=nameWithType>.
- Методы для `operator ==` и `operator !=`.
- Типы записей реализуют <xref:System.IEquatable%601?displayProperty=nameWithType>.

Кроме того, записи обеспечивают переопределение <xref:System.Object.ToString?displayProperty=nameWithType>. Компилятор синтезирует методы для отображения записей с помощью <xref:System.Object.ToString?displayProperty=nameWithType>. Эти элементы будут рассмотрены при написании кода для этого учебника. Записи поддерживают выражения `with`, позволяющие выполнять обратимое изменение записей.

Вы также можете объявить *позиционные записи*, используя более краткий синтаксис. При объявлении позиционных записей компилятор синтезирует дополнительные методы:

- Основной конструктор, параметры которого соответствуют позиционным параметрам в объявлении записи.
- Открытые свойства только для инициализации для каждого параметра основного конструктора.
- Метод `Deconstruct` для извлечения свойств из записи.

## <a name="build-temperature-data"></a>Создание данных о температуре

Данные и статистика представляют собой сценарии, в которых необходимо использовать записи. В этом учебнике вы создадите приложение, которое вычисляет *градусо-дни* для разных целей. *Градусо-дни* представляют собой меру тепла (или недостатка тепла) в течение нескольких дней, недель или месяцев. Градусо-дни позволяют отслеживать и прогнозировать использование энергии. Чем больше жарких дней, тем больше будет использоваться кондиционер, а чем больше холодных дней, тем больше будут использоваться обогреватели. Градусо-дни помогают управлять популяцией растений. Градусо-дни связаны с ростом растений по мере изменения времени года. Градусо-дни помогают отслеживать миграцию животных в зависимости от климата.

Формула основана на средней температуре в определенный день и базовой температуре. Чтобы вычислить градусо-дни за период времени, вам нужно знать высокую и низкую температуру каждого дня этого периода. Давайте начнем с создания нового приложения. Создание нового консольного приложения. Создать новый тип записи в новом файле с именем DailyTemperature.cs:

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DailyRecord":::

В предыдущем коде определяется *позиционная запись*. Вы создали ссылочный тип, содержащий два свойства: `HighTemp` и `LowTemp`. Эти свойства являются *свойствами только для инициализации*, то есть их можно задать в конструкторе или с помощью инициализатора свойств. Тип `DailyTemperature` также имеет *основной конструктор* с двумя параметрами, соответствующими двум свойствам. Основной конструктор используется для инициализации записи `DailyTemperature`:

:::code language="csharp" source="snippets/record-types/Program.cs" ID="DeclareData":::

В записи можно добавлять собственные свойства или методы, включая позиционные записи. Необходимо вычислить среднюю температуру каждого дня. Это свойство можно добавить в запись `DailyTemperature`:

:::code language="csharp" source="snippets/record-types/DailyTemperature.cs" ID="TemperatureRecord":::

Давайте убедимся, что вы можете использовать эти данные. Добавьте приведенный ниже код в метод `Main`:

```csharp
foreach (var item in data)
    Console.WriteLine(item);
```

Запустите приложение, и вы увидите результат, похожий на следующий (несколько строк удалено для экономии места):

```dotnetcli
DailyTemperature { HighTemp = 57, LowTemp = 30, Mean = 43.5 }
DailyTemperature { HighTemp = 60, LowTemp = 35, Mean = 47.5 }


DailyTemperature { HighTemp = 80, LowTemp = 60, Mean = 70 }
DailyTemperature { HighTemp = 85, LowTemp = 66, Mean = 75.5 }
```

В приведенном выше коде показаны выходные данные переопределения `ToString`, синтезированные компилятором. Если вы предпочитаете другой текст, можно написать собственную версию `ToString`. Компилятор не будет синтезировать версию автоматически.

## <a name="compute-degree-days"></a>Вычисление градусо-дней

Чтобы вычислить градусо-дни, нужно взять разность между базовой температурой и средней температурой за определенный день. Чтобы измерить теплые дни за период времени, не учитывайте дни, когда средняя температура была ниже базовой. Чтобы измерить холодные дни за период времени, не учитывайте дни, когда средняя температура была выше базовой. Например, в США за основу берется 65 градусов по Фаренгейту. В эту температуру не требуется включать нагрев или охлаждение. Если средняя температура дня составляет 70 градусов по Фаренгейту, это 5 градусо-дней в плане охлаждения и 0 градусо-дней в плане обогрева. Если средняя температура дня составляет 55 градусов по Фаренгейту, это 0 градусо-дней в плане охлаждения и 10 градусо-дней в плане обогрева.

Эти формулы можно выразить как небольшую иерархию типов записей: абстрактный тип градусо-дней и два конкретных типа для градусо-дней обогрева и градусо-дней охлаждения. Эти типы также могут быть позиционными записями. Они принимают базовую температуру и последовательность ежедневных записей температуры в качестве аргументов для основного конструктора:

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DegreeDaysRecords":::

Абстрактная запись `DegreeDays` является общим базовым классом для записей `HeatingDegreeDays` и `CoolingDegreeDays`. Объявления основного конструктора в производных записях показывают, как управлять инициализацией базовой записи. Ваша производная запись объявляет параметры для всех параметров в основном конструкторе базовой записи. Базовая запись объявляет и инициализирует эти свойства. Производная запись не скрывает их, но создает и инициализирует только свойства для параметров, которые не объявлены в базовой записи. В этом примере производные записи не добавляют новые параметры основного конструктора. Протестируйте код, добавив следующий код в метод `Main`:

:::code language="csharp" source="snippets/record-types/Program.cs" ID="HeatingAndCooling":::

Вы получите выходные данные, подобные следующим:

```dotnetcli
HeatingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 85 }
CoolingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 71.5 }
```

## <a name="define-compiler-synthesized-methods"></a>Определение методов, синтезируемых компилятором

В коде вычисляется правильное число градусо-дней обогрева и охлаждения за этот период времени. Но в этом примере показано, почему может потребоваться заменить некоторые синтезированные методы на записи. Вы можете объявить собственную версию любых синтезированных компилятором методов в типе записи, за исключением метода клонирования. Метод клонирования имеет имя, созданное компилятором, и вы не можете предоставить другую реализацию. Эти синтезированные методы включают конструктор копий, элементы интерфейса <xref:System.IEquatable%601?displayProperty=nameWithType>, проверки равенства и неравенства, а также <xref:System.Object.GetHashCode>. Для этой цели вы создадите `PrintMembers`. Можно также объявить собственный `ToString`, но `PrintMembers` предоставляет лучший вариант для сценариев наследования. Чтобы предоставить собственную версию синтезированного метода, сигнатура должна соответствовать синтезированному методу.

Элемент `TempRecords` в выходных данных консоли не имеет смысла. Он отображает тип, но больше ничего. Это поведение можно изменить, предоставив собственную реализацию синтезированного метода `PrintMembers`. Сигнатура зависит от модификаторов, применяемых к объявлению `record`:

- Если тип записи — `sealed`, то сигнатура — `private bool PrintMembers(StringBuilder builder);`
- Если тип записи не `sealed` и является производным от `object` (то есть базовая запись не объявляется), то сигнатура — `protected virtual bool PrintMembers(StringBuilder builder);`
- Если тип записи не `sealed` и является производным от другой записи, то сигнатура — `protected override bool PrintMembers(StringBuilder builder);`

Эти правила проще всего осмыслить, поняв цель `PrintMembers`. `PrintMembers` добавляет сведения о каждом свойстве в типе записи в строку. По контракту базовые записи должны добавлять свои элементы в отображение. Предполагается, что производные элементы будут добавлять свои элементы. Каждый тип записи синтезирует переопределение `ToString`, которое выглядит следующим образом для `HeatingDegreeDays`:

```csharp
public override string ToString()
{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.Append("HeatingDegreeDays");
    stringBuilder.Append(" { ");
    if (PrintMembers(stringBuilder))
    {
        stringBuilder.Append(" ");
    }
    stringBuilder.Append("}");
    return stringBuilder.ToString();
}
```

Вы объявляете метод `PrintMembers` в записи `DegreeDays`, которая не выводит тип коллекции:

:::code language="csharp" source="snippets/record-types/DegreeDays.cs" ID="AddPrintMembers":::

Сигнатура объявляет метод `virtual protected`, чтобы обеспечить соответствие версии компилятора. Не беспокойтесь, если получаете неправильные методы доступа; язык применит правильную сигнатуру. Если вы забыли правильные модификаторы для синтезированного метода, компилятор выдает предупреждения или ошибки, которые помогут получить правильную сигнатуру.

## <a name="non-destructive-mutation"></a>Обратимое изменение

Синтезированные элементы в позиционной записи не изменяют состояние записи. Главная цель — упростить создание неизменяемых записей. Просмотрите предыдущие объявления для `HeatingDegreeDays` и `CoolingDegreeDays`. Добавленные элементы выполняют вычисления со значениями для записи, но не изменяют состояние. Позиционные записи упрощают создание неизменяемых ссылочных типов.

Создание неизменяемых ссылочных типов означает, что необходимо использовать обратимое изменение. Вы создаете новые экземпляры записей, аналогичные существующим экземплярам записей, используя [выражения `with`](../../language-reference/operators/with-expression.md). Эти выражения являются конструкцией копии с дополнительными назначениями, которые изменяют копию. Результатом является новый экземпляр записи, где каждое свойство было скопировано из существующей записи и при необходимости изменено. Исходная запись не изменится.

Давайте добавим в программу несколько функций, демонстрирующих выражения `with`. Во-первых, создадим новую запись для вычислений рост градусо-дней, используя те же данные. *Рост градусо-дней* обычно использует 41 градус по Фаренгейту в качестве базового показателя и измеряет температуру выше базовой. Чтобы использовать те же данные, можно создать новую запись, похожую на `coolingDegreeDays`, но с другой базовой температурой:

:::code language="csharp" source="snippets/record-types/Program.cs" ID="GrowingDegreeDays":::

Вы можете сравнить число рассчитанных градусов с числом, вычисленным при более высокой базовой температуре. Помните, что записи являются *ссылочными типами*, и эти копии являются поверхностными копиями. Массив данных не копируется, но обе записи ссылаются на одни и те же данные. Этот факт является преимуществом в еще одном сценарии. Для растущих градусо-дней полезно отслеживать общее число за предыдущие 5 дней. С помощью выражений `with` можно создавать новые записи с разными исходными данными. Следующий код создает коллекцию этих сумм, а затем отображает значения:

:::code language="csharp" source="snippets/record-types/Program.cs" ID="RunningFiveDayTotal":::

Можно также использовать выражения `with` для создания копий записей. Не указывайте свойства между фигурными скобками в выражении `with`. Это означает, что нужно создать копию и не менять свойства:

```csharp
var growingDegreeDaysCopy = growingDegreeDays with { };
```

Запустите готовое приложение, чтобы увидеть результаты.

## <a name="summary"></a>Сводка

В этом учебнике мы рассмотрели несколько аспектов записей. Записи предоставляют краткий синтаксис для ссылочных типов, где главная цель — хранение данных. Для объектно-ориентированных классов основным назначением является определение обязанностей. В этом учебнике вы узнали о *позиционных записях*, где можно использовать краткий синтаксис для объявления свойств записи, предназначенных только для инициализации. Компилятор синтезирует несколько элементов записи для копирования и сравнения записей. Вы можете добавить любые другие элементы, необходимые для ваших типов записей. Вы можете создавать неизменяемые типы записей, зная, что ни один из созданных компилятором элементов не изменит состояние. Для позиционных записей выражения `with` упрощают поддержку обратимого изменения.

Записи добавляют еще один способ определения типов. Определения `class` используются для создания объектно-ориентированных иерархий, в которых основное внимание уделяется обязанностям и поведению объектов. Вы создаете типы `struct` для структур данных, которые хранят данные и достаточно малы для эффективного копирования. Вы создаете записи, когда хотите определить равенство и сравнение на основе значений, но не хотите копировать значения, а хотите использовать ссылочные переменные.

Полное описание записей приводится в [предлагаемой спецификации типа записи](~/_csharplang/proposals/csharp-9.0/records.md).
