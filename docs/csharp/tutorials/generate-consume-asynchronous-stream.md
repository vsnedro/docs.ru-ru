---
title: Создание и использование асинхронных потоков
description: В этом расширенном руководстве показано, как создавать и использовать асинхронные потоки. Асинхронные потоки предоставляют более естественный способ работы с последовательностями данных, которые могут создаваться асинхронно.
ms.date: 02/10/2019
ms.technology: csharp-async
ms.custom: mvc
ms.openlocfilehash: fd9fed3469d18c919102640df7bb501b116f5e0e
ms.sourcegitcommit: 9a4488a3625866335e83a20da5e9c5286b1f034c
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/15/2020
ms.locfileid: "83420374"
---
# <a name="tutorial-generate-and-consume-async-streams-using-c-80-and-net-core-30"></a><span data-ttu-id="b029e-104">Учебник. Создание и использование асинхронных потоков с использованием C# 8.0 и .NET Core 3.0</span><span class="sxs-lookup"><span data-stu-id="b029e-104">Tutorial: Generate and consume async streams using C# 8.0 and .NET Core 3.0</span></span>

<span data-ttu-id="b029e-105">В C# 8.0 представлены **асинхронные потоки**, которые моделируют источник данных потоковой передачи.</span><span class="sxs-lookup"><span data-stu-id="b029e-105">C# 8.0 introduces **async streams**, which model a streaming source of data.</span></span> <span data-ttu-id="b029e-106">Потоки данных часто извлекают или создают элементы асинхронно.</span><span class="sxs-lookup"><span data-stu-id="b029e-106">Data streams often retrieve or generate elements asynchronously.</span></span> <span data-ttu-id="b029e-107">Асинхронные потоки полагаются на новые интерфейсы, появившиеся в .NET Standard 2.1.</span><span class="sxs-lookup"><span data-stu-id="b029e-107">Async streams rely on new interfaces introduced in .NET Standard 2.1.</span></span> <span data-ttu-id="b029e-108">Эти интерфейсы поддерживаются в .NET Core 3.0 и более поздних версиях.</span><span class="sxs-lookup"><span data-stu-id="b029e-108">These interfaces are supported in .NET Core 3.0 and later.</span></span> <span data-ttu-id="b029e-109">Они предоставляют естественную модель программирования для асинхронных потоковых источников данных.</span><span class="sxs-lookup"><span data-stu-id="b029e-109">They provide a natural programming model for asynchronous streaming data sources.</span></span>

<span data-ttu-id="b029e-110">В этом руководстве вы узнаете, как:</span><span class="sxs-lookup"><span data-stu-id="b029e-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="b029e-111">Создать источник данных, который формирует последовательность элементов данных асинхронно.</span><span class="sxs-lookup"><span data-stu-id="b029e-111">Create a data source that generates a sequence of data elements asynchronously.</span></span>
> - <span data-ttu-id="b029e-112">Использовать этот источник данных асинхронно.</span><span class="sxs-lookup"><span data-stu-id="b029e-112">Consume that data source asynchronously.</span></span>
> - <span data-ttu-id="b029e-113">Поддержка отмены и перехваченных контекстов для асинхронных потоков.</span><span class="sxs-lookup"><span data-stu-id="b029e-113">Support cancellation and captured contexts for asynchronous streams.</span></span>
> - <span data-ttu-id="b029e-114">Распознавать, когда новый интерфейс и источник данных предпочтительнее для более ранних синхронных последовательностей данных.</span><span class="sxs-lookup"><span data-stu-id="b029e-114">Recognize when the new interface and data source are preferred to earlier synchronous data sequences.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="b029e-115">Предварительные требования</span><span class="sxs-lookup"><span data-stu-id="b029e-115">Prerequisites</span></span>

<span data-ttu-id="b029e-116">Вам нужно настроить свой компьютер для выполнения .NET Core, включая компилятор C# 8.0.</span><span class="sxs-lookup"><span data-stu-id="b029e-116">You'll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="b029e-117">Компилятор C# 8 доступен, начиная с [версии 16.3 Visual Studio 2019](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) или [в пакете SDK .NET Core 3.0](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="b029e-117">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="b029e-118">Чтобы вы могли получить доступ к конечной точке GraphQL GitHub, необходимо создать [маркер доступа GitHub](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token).</span><span class="sxs-lookup"><span data-stu-id="b029e-118">You'll need to create a [GitHub access token](https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token) so that you can access the GitHub GraphQL endpoint.</span></span> <span data-ttu-id="b029e-119">Выберите следующие разрешения для маркеров доступа GitHub.</span><span class="sxs-lookup"><span data-stu-id="b029e-119">Select the following permissions for your GitHub Access Token:</span></span>

- <span data-ttu-id="b029e-120">repo:status</span><span class="sxs-lookup"><span data-stu-id="b029e-120">repo:status</span></span>
- <span data-ttu-id="b029e-121">public_repo</span><span class="sxs-lookup"><span data-stu-id="b029e-121">public_repo</span></span>

<span data-ttu-id="b029e-122">Храните маркер доступа в надежном месте, чтобы вы могли использовать его для получения доступа к конечной точке API GitHub.</span><span class="sxs-lookup"><span data-stu-id="b029e-122">Save the access token in a safe place so you can use it to gain access to the GitHub API endpoint.</span></span>

> [!WARNING]
> <span data-ttu-id="b029e-123">Храните свой личный маркер доступа в безопасном месте.</span><span class="sxs-lookup"><span data-stu-id="b029e-123">Keep your personal access token secure.</span></span> <span data-ttu-id="b029e-124">Любое программное обеспечение с вашим личным маркером доступа может выполнять вызовы API GitHub с помощью ваших прав доступа.</span><span class="sxs-lookup"><span data-stu-id="b029e-124">Any software with your personal access token could make GitHub API calls using your access rights.</span></span>

<span data-ttu-id="b029e-125">В этом руководстве предполагается, что вы знакомы с C# и .NET, включая Visual Studio или .NET Core CLI.</span><span class="sxs-lookup"><span data-stu-id="b029e-125">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="run-the-starter-application"></a><span data-ttu-id="b029e-126">Запуск начального приложения</span><span class="sxs-lookup"><span data-stu-id="b029e-126">Run the starter application</span></span>

<span data-ttu-id="b029e-127">Вы можете получить код для начального приложения, используемый в этом руководстве в репозитории [dotnet/docs](https://github.com/dotnet/docs) в папке [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start).</span><span class="sxs-lookup"><span data-stu-id="b029e-127">You can get the code for the starter application used in this tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/start) folder.</span></span>

<span data-ttu-id="b029e-128">Начальное приложение представляет собой консольное приложение, которое использует интерфейс [GraphQL GitHub](https://developer.github.com/v4/) для получения последних проблем, написанных в репозитории [dotnet/docs](https://github.com/dotnet/docs).</span><span class="sxs-lookup"><span data-stu-id="b029e-128">The starter application is a console application that uses the [GitHub GraphQL](https://developer.github.com/v4/) interface to retrieve recent issues written in the [dotnet/docs](https://github.com/dotnet/docs) repository.</span></span> <span data-ttu-id="b029e-129">Начнем с просмотра следующего кода для метода `Main` начального приложения.</span><span class="sxs-lookup"><span data-stu-id="b029e-129">Start by looking at the following code for the starter app `Main` method:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetStarterAppMain" :::

<span data-ttu-id="b029e-130">Вы можете задать переменную среды `GitHubKey` личному маркеру доступа или заменить последний аргумент в вызове на `GenEnvVariable` с помощью личного маркера доступа.</span><span class="sxs-lookup"><span data-stu-id="b029e-130">You can either set a `GitHubKey` environment variable to your personal access token, or you can replace the last argument in the call to `GenEnvVariable` with your personal access token.</span></span> <span data-ttu-id="b029e-131">Не размещайте код доступа в исходном коде, если будете предоставлять общий доступ к источнику другим пользователям.</span><span class="sxs-lookup"><span data-stu-id="b029e-131">Don't put your access code in source code if you'll be sharing the source with others.</span></span> <span data-ttu-id="b029e-132">Никогда не отправляйте коды доступа в репозиторий с общим исходным кодом.</span><span class="sxs-lookup"><span data-stu-id="b029e-132">Never upload access codes to a shared source repository.</span></span>

<span data-ttu-id="b029e-133">После создания клиента GitHub код в `Main` создает объект отчета о ходе выполнения и маркер отмены.</span><span class="sxs-lookup"><span data-stu-id="b029e-133">After creating the GitHub client, the code in `Main` creates a progress reporting object and a cancellation token.</span></span> <span data-ttu-id="b029e-134">После создания этих объектов `Main` вызывает `runPagedQueryAsync`, чтобы получить более 250 недавно созданных проблем.</span><span class="sxs-lookup"><span data-stu-id="b029e-134">Once those objects are created, `Main` calls `runPagedQueryAsync` to retrieve the most recent 250 created issues.</span></span> <span data-ttu-id="b029e-135">Результаты отобразятся после выполнения этой задачи.</span><span class="sxs-lookup"><span data-stu-id="b029e-135">After that task has finished, the results are displayed.</span></span>

<span data-ttu-id="b029e-136">При запуске начального приложения вы можете обнаружить некоторые важные замечания о том, как будет выполняться приложение.</span><span class="sxs-lookup"><span data-stu-id="b029e-136">When you run the starter application, you can make some important observations about how this application runs.</span></span>  <span data-ttu-id="b029e-137">Вы увидите ход выполнения, передаваемый каждой странице, возвращенной с GitHub.</span><span class="sxs-lookup"><span data-stu-id="b029e-137">You'll see progress reported for each page returned from GitHub.</span></span> <span data-ttu-id="b029e-138">Прежде чем GitHub вернет каждую новую страницу проблем, возникает заметная пауза.</span><span class="sxs-lookup"><span data-stu-id="b029e-138">You can observe a noticeable pause before GitHub returns each new page of issues.</span></span> <span data-ttu-id="b029e-139">Наконец, проблемы отображаются только после того, как получены все 10 страниц с GitHub.</span><span class="sxs-lookup"><span data-stu-id="b029e-139">Finally, the issues are displayed only after all 10 pages have been retrieved from GitHub.</span></span>

## <a name="examine-the-implementation"></a><span data-ttu-id="b029e-140">Изучение реализации</span><span class="sxs-lookup"><span data-stu-id="b029e-140">Examine the implementation</span></span>

<span data-ttu-id="b029e-141">Реализация показывает, почему возникло поведение, обсуждавшееся в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="b029e-141">The implementation reveals why you observed the behavior discussed in the previous section.</span></span> <span data-ttu-id="b029e-142">Изучите код для `runPagedQueryAsync`.</span><span class="sxs-lookup"><span data-stu-id="b029e-142">Examine the code for `runPagedQueryAsync`:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetRunPagedQuery" :::

<span data-ttu-id="b029e-143">Давайте сконцентрируемся на алгоритме разбивки по страницам и асинхронной структуре предыдущего кода.</span><span class="sxs-lookup"><span data-stu-id="b029e-143">Let's concentrate on the paging algorithm and async structure of the preceding code.</span></span> <span data-ttu-id="b029e-144">(Дополнительные сведения об API GraphQL GitHub см. в [этой документации](https://developer.github.com/v4/guides/).) Метод `runPagedQueryAsync` перечисляет проблемы от самых последних до самых старых.</span><span class="sxs-lookup"><span data-stu-id="b029e-144">(You can consult the [GitHub GraphQL documentation](https://developer.github.com/v4/guides/) for details on the GitHub GraphQL API.) The `runPagedQueryAsync` method enumerates the issues from most recent to oldest.</span></span> <span data-ttu-id="b029e-145">Чтобы продолжить с предыдущей страницы, он запрашивает по 25 выпусков на страницу и проверяет структуру ответа `pageInfo`.</span><span class="sxs-lookup"><span data-stu-id="b029e-145">It requests 25 issues per page and examines the `pageInfo` structure of the response to continue with the previous page.</span></span> <span data-ttu-id="b029e-146">Это следует за стандартной поддержкой страниц GraphQL для многостраничных ответов.</span><span class="sxs-lookup"><span data-stu-id="b029e-146">That follows GraphQL's standard paging support for multi-page responses.</span></span> <span data-ttu-id="b029e-147">Ответ включает в себя объект `pageInfo`, который содержит значение `hasPreviousPages` и `startCursor`, используемые для запроса предыдущей страницы.</span><span class="sxs-lookup"><span data-stu-id="b029e-147">The response includes a `pageInfo` object that includes a `hasPreviousPages` value and a `startCursor` value used to request the previous page.</span></span> <span data-ttu-id="b029e-148">Проблемы в массиве `nodes`.</span><span class="sxs-lookup"><span data-stu-id="b029e-148">The issues are in the `nodes` array.</span></span> <span data-ttu-id="b029e-149">Метод `runPagedQueryAsync` добавляет эти узлы в массив, который содержит результаты со всех страниц.</span><span class="sxs-lookup"><span data-stu-id="b029e-149">The `runPagedQueryAsync` method appends these nodes to an array that contains all the results from all pages.</span></span>

<span data-ttu-id="b029e-150">После получения и восстановления страницы результатов `runPagedQueryAsync` сообщает о ходе выполнения и проверяет наличие отмены.</span><span class="sxs-lookup"><span data-stu-id="b029e-150">After retrieving and restoring a page of results, `runPagedQueryAsync` reports progress and checks for cancellation.</span></span> <span data-ttu-id="b029e-151">Если есть запрос на отмену, `runPagedQueryAsync` выдает <xref:System.OperationCanceledException>.</span><span class="sxs-lookup"><span data-stu-id="b029e-151">If cancellation has been requested, `runPagedQueryAsync` throws an <xref:System.OperationCanceledException>.</span></span>

<span data-ttu-id="b029e-152">Существует несколько элементов в этом коде, которые можно улучшить.</span><span class="sxs-lookup"><span data-stu-id="b029e-152">There are several elements in this code that can be improved.</span></span> <span data-ttu-id="b029e-153">Самое главное, `runPagedQueryAsync` должен выделить хранилище для всех возвращенных проблем.</span><span class="sxs-lookup"><span data-stu-id="b029e-153">Most importantly, `runPagedQueryAsync` must allocate storage for all the issues returned.</span></span> <span data-ttu-id="b029e-154">Этот пример останавливается после нахождения 250 проблем, так как для извлечения всех открытых проблем потребуется гораздо больше памяти на их хранение.</span><span class="sxs-lookup"><span data-stu-id="b029e-154">This sample stops at 250 issues because retrieving all open issues would require much more memory to store all the retrieved issues.</span></span> <span data-ttu-id="b029e-155">Протоколы для поддержки отчетов о ходе выполнения и отмены делают алгоритм более сложным для понимания при первом чтении.</span><span class="sxs-lookup"><span data-stu-id="b029e-155">The protocols for supporting progress reports and cancellation make the algorithm harder to understand on its first reading.</span></span> <span data-ttu-id="b029e-156">Задействовано больше типов и API.</span><span class="sxs-lookup"><span data-stu-id="b029e-156">More types and APIs are involved.</span></span> <span data-ttu-id="b029e-157">Вы должны отслеживать передачу данных с помощью <xref:System.Threading.CancellationTokenSource> и связанного с ним <xref:System.Threading.CancellationToken>, чтобы понять, где запрашивается отмена и где она предоставляется.</span><span class="sxs-lookup"><span data-stu-id="b029e-157">You must trace the communications through the <xref:System.Threading.CancellationTokenSource> and its associated <xref:System.Threading.CancellationToken> to understand where cancellation is requested and where it's granted.</span></span>

## <a name="async-streams-provide-a-better-way"></a><span data-ttu-id="b029e-158">Предоставление лучшего способа асинхронных потоков</span><span class="sxs-lookup"><span data-stu-id="b029e-158">Async streams provide a better way</span></span>

<span data-ttu-id="b029e-159">Асинхронные потоки и связанная языковая поддержка обращаются ко всем этим вопросам.</span><span class="sxs-lookup"><span data-stu-id="b029e-159">Async streams and the associated language support address all those concerns.</span></span> <span data-ttu-id="b029e-160">Код, который формирует последовательность, теперь может использовать `yield return` для возврата элементов в методе, который был объявлен с помощью модификатора `async`.</span><span class="sxs-lookup"><span data-stu-id="b029e-160">The code that generates the sequence can now use `yield return` to return elements in a method that was declared with the `async` modifier.</span></span> <span data-ttu-id="b029e-161">Вы можете применить асинхронный поток, используя цикл `await foreach`, аналогично любой последовательности с помощью цикла `foreach`.</span><span class="sxs-lookup"><span data-stu-id="b029e-161">You can consume an async stream using an `await foreach` loop just as you consume any sequence using a `foreach` loop.</span></span>

<span data-ttu-id="b029e-162">Эти новые языковые функции зависят от трех новых интерфейсов, добавленных в .NET Standard 2.1 и реализованных в .NET Core 3.0.</span><span class="sxs-lookup"><span data-stu-id="b029e-162">These new language features depend on three new interfaces added to .NET Standard 2.1 and implemented in .NET Core 3.0:</span></span>

- <xref:System.Collections.Generic.IAsyncEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IAsyncEnumerator%601?displayProperty=nameWithType>
- <xref:System.IAsyncDisposable?displayProperty=nameWithType>

<span data-ttu-id="b029e-163">Большинство разработчиков C# должны знать об этих трех интерфейсах.</span><span class="sxs-lookup"><span data-stu-id="b029e-163">These three interfaces should be familiar to most C# developers.</span></span> <span data-ttu-id="b029e-164">Они ведут себя подобно своим синхронным аналогам.</span><span class="sxs-lookup"><span data-stu-id="b029e-164">They behave in a manner similar to their synchronous counterparts:</span></span>

- <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>
- <xref:System.Collections.Generic.IEnumerator%601?displayProperty=nameWithType>
- <xref:System.IDisposable?displayProperty=nameWithType>

<span data-ttu-id="b029e-165">Один тип, который может быть незнаком, — <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b029e-165">One type that may be unfamiliar is <xref:System.Threading.Tasks.ValueTask?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b029e-166">Структура `ValueTask` предоставляет API, аналогичный классу <xref:System.Threading.Tasks.Task?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b029e-166">The `ValueTask` struct provides a similar API to the <xref:System.Threading.Tasks.Task?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="b029e-167">`ValueTask` используется в этих интерфейсах по причинам производительности.</span><span class="sxs-lookup"><span data-stu-id="b029e-167">`ValueTask` is used in these interfaces for performance reasons.</span></span>

## <a name="convert-to-async-streams"></a><span data-ttu-id="b029e-168">Преобразование в асинхронные потоки</span><span class="sxs-lookup"><span data-stu-id="b029e-168">Convert to async streams</span></span>

<span data-ttu-id="b029e-169">Затем для создания асинхронного потока преобразуйте метод `runPagedQueryAsync`.</span><span class="sxs-lookup"><span data-stu-id="b029e-169">Next, convert the `runPagedQueryAsync` method to generate an async stream.</span></span> <span data-ttu-id="b029e-170">Сначала измените подпись `runPagedQueryAsync`, чтобы вернуть `IAsyncEnumerable<JToken>`, затем удалите маркер отмены и объекты хода выполнения из списка параметров, как показано в следующем коде.</span><span class="sxs-lookup"><span data-stu-id="b029e-170">First, change the signature of `runPagedQueryAsync` to return an `IAsyncEnumerable<JToken>`, and remove the cancellation token and progress objects from the parameter list as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetUpdateSignature" :::

<span data-ttu-id="b029e-171">В следующем коде показано, как начальный код обрабатывает каждую страницу для извлечения.</span><span class="sxs-lookup"><span data-stu-id="b029e-171">The starter code processes each page as the page is retrieved, as shown in the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetProcessPage" :::

<span data-ttu-id="b029e-172">Замените эти три строки следующим кодом.</span><span class="sxs-lookup"><span data-stu-id="b029e-172">Replace those three lines with the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetYieldReturnPage" :::

<span data-ttu-id="b029e-173">Вы также можете удалить объявление `finalResults` ранее в этом методе и оператор `return`, следующий за измененным циклом.</span><span class="sxs-lookup"><span data-stu-id="b029e-173">You can also remove the declaration of `finalResults` earlier in this method and the `return` statement that follows the loop you modified.</span></span>

<span data-ttu-id="b029e-174">Вы завершили изменения для создания асинхронного потока.</span><span class="sxs-lookup"><span data-stu-id="b029e-174">You've finished the changes to generate an async stream.</span></span> <span data-ttu-id="b029e-175">Готовый метод должен иметь вид, аналогичный приведенному ниже коду:</span><span class="sxs-lookup"><span data-stu-id="b029e-175">The finished method should resemble the following code:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateAsyncStream" :::

<span data-ttu-id="b029e-176">Затем измените код, который использует коллекцию, для асинхронного потока.</span><span class="sxs-lookup"><span data-stu-id="b029e-176">Next, you change the code that consumes the collection to consume the async stream.</span></span> <span data-ttu-id="b029e-177">Найдите следующий код в `Main`, который обрабатывает коллекцию проблем.</span><span class="sxs-lookup"><span data-stu-id="b029e-177">Find the following code in `Main` that processes the collection of issues:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/start/Program.cs" id="SnippetEnumerateOldStyle" :::

<span data-ttu-id="b029e-178">Замените код следующим циклом `await foreach`.</span><span class="sxs-lookup"><span data-stu-id="b029e-178">Replace that code with the following `await foreach` loop:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateAsyncStream" :::

<span data-ttu-id="b029e-179">Новый интерфейс <xref:System.Collections.Generic.IAsyncEnumerator%601> является производным от <xref:System.IAsyncDisposable>.</span><span class="sxs-lookup"><span data-stu-id="b029e-179">The new interface <xref:System.Collections.Generic.IAsyncEnumerator%601> derives from <xref:System.IAsyncDisposable>.</span></span> <span data-ttu-id="b029e-180">Это означает, что предыдущий цикл будет асинхронно удалять поток по завершении цикла.</span><span class="sxs-lookup"><span data-stu-id="b029e-180">That means the preceding loop will asynchronously dispose the stream when the loop finishes.</span></span> <span data-ttu-id="b029e-181">Цикл похож на следующий код:</span><span class="sxs-lookup"><span data-stu-id="b029e-181">You can imagine the loop looks like the following code:</span></span>

```csharp
int num = 0;
var enumerator = runPagedQueryAsync(client, PagedIssueQuery, "docs").GetEnumeratorAsync();
try
{
    while (await enumerator.MoveNextAsync())
    {
        var issue = enumerator.Current;
        Console.WriteLine(issue);
        Console.WriteLine($"Received {++num} issues in total");
    }
} finally
{
    if (enumerator != null)
        await enumerator.DisposeAsync();
}
```

<span data-ttu-id="b029e-182">Элементы потока по умолчанию обрабатываются в захваченном контексте.</span><span class="sxs-lookup"><span data-stu-id="b029e-182">By default, stream elements are processed in the captured context.</span></span> <span data-ttu-id="b029e-183">Чтобы отключить захват контекста, используйте метод расширения <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b029e-183">If you want to disable capturing of the context, use the <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.ConfigureAwait%2A?displayProperty=nameWithType> extension method.</span></span> <span data-ttu-id="b029e-184">Дополнительные сведения о контекстах синхронизации и захвате текущего контекста см. в [статье](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md), посвященной использованию асинхронной модели на основе задач.</span><span class="sxs-lookup"><span data-stu-id="b029e-184">For more information about synchronization contexts and capturing the current context, see the article on [consuming the Task-based asynchronous pattern](../../standard/asynchronous-programming-patterns/consuming-the-task-based-asynchronous-pattern.md).</span></span>

<span data-ttu-id="b029e-185">Асинхронные потоки поддерживают отмену, используя тот же протокол, что и другие методы `async`.</span><span class="sxs-lookup"><span data-stu-id="b029e-185">Async streams support cancellation using the same protocol as other `async` methods.</span></span> <span data-ttu-id="b029e-186">Для поддержки отмены можно изменить сигнатуру для метода асинхронного итератора следующим образом:</span><span class="sxs-lookup"><span data-stu-id="b029e-186">You would modify the signature for the async iterator method as follows to support cancellation:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetGenerateWithCancellation" :::

<span data-ttu-id="b029e-187">Атрибут <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> заставляет компилятор создать код для <xref:System.Collections.Generic.IAsyncEnumerator%601>, который делает токен, передаваемый `GetAsyncEnumerator`, видимым в тексте асинхронного итератора в виде аргумента.</span><span class="sxs-lookup"><span data-stu-id="b029e-187">The <xref:System.Runtime.CompilerServices.EnumeratorCancellationAttribute?dipslayProperty=nameWithType> attribute causes the compiler to generate code for the <xref:System.Collections.Generic.IAsyncEnumerator%601> that makes the token passed to `GetAsyncEnumerator` visible to the body of the async iterator as that argument.</span></span> <span data-ttu-id="b029e-188">Внутри `runQueryAsync` можно проверить состояние маркера и отменить дальнейшую работу при необходимости.</span><span class="sxs-lookup"><span data-stu-id="b029e-188">Inside `runQueryAsync`, you could examine the state of the token and cancel further work if requested.</span></span>

<span data-ttu-id="b029e-189">Используйте другой метод расширения, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, чтобы передать токен отмены асинхронному потоку.</span><span class="sxs-lookup"><span data-stu-id="b029e-189">You use another extension method, <xref:System.Threading.Tasks.TaskAsyncEnumerableExtensions.WithCancellation%2A>, to pass the cancellation token to the async stream.</span></span> <span data-ttu-id="b029e-190">Измените цикл, перечисляя проблемы следующим образом:</span><span class="sxs-lookup"><span data-stu-id="b029e-190">You would modify the loop enumerating the issues as follows:</span></span>

:::code language="csharp" source="snippets/generate-consume-asynchronous-streams/finished/Program.cs" id="SnippetEnumerateWithCancellation" :::

<span data-ttu-id="b029e-191">Вы можете получить код для готового руководства из репозитория [dotnet/docs](https://github.com/dotnet/docs) в папке [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished).</span><span class="sxs-lookup"><span data-stu-id="b029e-191">You can get the code for the finished tutorial from the [dotnet/docs](https://github.com/dotnet/docs) repository in the [csharp/tutorials/AsyncStreams](https://github.com/dotnet/docs/tree/master/docs/csharp/tutorials/snippets/generate-consume-asynchronous-streams/finished) folder.</span></span>

## <a name="run-the-finished-application"></a><span data-ttu-id="b029e-192">Запуск готового приложения</span><span class="sxs-lookup"><span data-stu-id="b029e-192">Run the finished application</span></span>

<span data-ttu-id="b029e-193">Снова запустите приложение.</span><span class="sxs-lookup"><span data-stu-id="b029e-193">Run the application again.</span></span> <span data-ttu-id="b029e-194">Сравните его поведение с поведением начального приложения.</span><span class="sxs-lookup"><span data-stu-id="b029e-194">Contrast its behavior with the behavior of the starter application.</span></span> <span data-ttu-id="b029e-195">Первая страница результатов перечисляется, как только она становится доступной.</span><span class="sxs-lookup"><span data-stu-id="b029e-195">The first page of results is enumerated as soon as it's available.</span></span> <span data-ttu-id="b029e-196">Поскольку каждую новую страницу запрашивают и извлекают, результаты следующей страницы быстро перечисляются, возникает пауза.</span><span class="sxs-lookup"><span data-stu-id="b029e-196">There's an observable pause as each new page is requested and retrieved, then the next page's results are quickly enumerated.</span></span> <span data-ttu-id="b029e-197">Блок `try` / `catch` не требует обработки отмены. Вызывающий может прекратить перечисление коллекции.</span><span class="sxs-lookup"><span data-stu-id="b029e-197">The `try` / `catch` block isn't needed to handle cancellation: the caller can stop enumerating the collection.</span></span> <span data-ttu-id="b029e-198">Отчет о ходе выполнения четко сформирован, так как асинхронный поток формирует результаты скачивания каждой страницы.</span><span class="sxs-lookup"><span data-stu-id="b029e-198">Progress is clearly reported because the async stream generates results as each page is downloaded.</span></span> <span data-ttu-id="b029e-199">Состояние каждой возвращенной проблемы включается в цикл `await foreach`.</span><span class="sxs-lookup"><span data-stu-id="b029e-199">The status for each issue returned is seamlessly included in the `await foreach` loop.</span></span> <span data-ttu-id="b029e-200">Для отслеживания хода выполнения объект обратного вызова не требуется.</span><span class="sxs-lookup"><span data-stu-id="b029e-200">You don't need a callback object to track progress.</span></span>

<span data-ttu-id="b029e-201">Изучив код, вы увидите улучшения в использовании памяти.</span><span class="sxs-lookup"><span data-stu-id="b029e-201">You can see improvements in memory use by examining the code.</span></span> <span data-ttu-id="b029e-202">Вам больше не нужно выделять коллекцию для хранения всех результатов до их перечисления.</span><span class="sxs-lookup"><span data-stu-id="b029e-202">You no longer need to allocate a collection to store all the results before they're enumerated.</span></span> <span data-ttu-id="b029e-203">Вызывающий может определить, как использовать результаты и нужен ли набор хранилищ.</span><span class="sxs-lookup"><span data-stu-id="b029e-203">The caller can determine how to consume the results and if a storage collection is needed.</span></span>

<span data-ttu-id="b029e-204">Запустите начальное и готовое приложение, и вы увидите различия между реализациями самостоятельно.</span><span class="sxs-lookup"><span data-stu-id="b029e-204">Run both the starter and finished applications and you can observe the differences between the implementations for yourself.</span></span> <span data-ttu-id="b029e-205">Вы можете удалить маркер доступа GitHub, созданный при начале работы с этим руководством, после завершения изучения.</span><span class="sxs-lookup"><span data-stu-id="b029e-205">You can delete the GitHub access token you created when you started this tutorial after you've finished.</span></span> <span data-ttu-id="b029e-206">Если злоумышленник получил доступ к этому маркеру, ему удастся получить доступ к API GitHub с помощью ваших учетных данных.</span><span class="sxs-lookup"><span data-stu-id="b029e-206">If an attacker gained access to that token, they could access GitHub APIs using your credentials.</span></span>
