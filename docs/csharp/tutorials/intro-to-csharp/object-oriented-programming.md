---
title: Объектно ориентированное программирование (C#)
description: C# обеспечивает полную поддержку объектно ориентированного программирования, включая абстракцию, инкапсуляцию, наследование и полиморфизм.
ms.date: 09/30/2020
ms.openlocfilehash: 6e0155621be544b01453b8c107debb3a9b6c38f9
ms.sourcegitcommit: e078b7540a8293ca1b604c9c0da1ff1506f0170b
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/13/2020
ms.locfileid: "91997662"
---
# <a name="object-oriented-programming-c"></a><span data-ttu-id="a79a0-103">Объектно-ориентированное программирование (C#)</span><span class="sxs-lookup"><span data-stu-id="a79a0-103">Object-Oriented programming (C#)</span></span>

<span data-ttu-id="a79a0-104">C# — это объектно-ориентированный язык.</span><span class="sxs-lookup"><span data-stu-id="a79a0-104">C# is an object-oriented language.</span></span> <span data-ttu-id="a79a0-105">В объектно-ориентированном программировании используются четыре основных метода:</span><span class="sxs-lookup"><span data-stu-id="a79a0-105">Four of the key techniques used in object-oriented programming are:</span></span>

- <span data-ttu-id="a79a0-106">*Абстракция* означает скрытие ненужных сведений от потребителей типов.</span><span class="sxs-lookup"><span data-stu-id="a79a0-106">*Abstraction* means hiding the unnecessary details from type consumers.</span></span>
- <span data-ttu-id="a79a0-107">*Инкапсуляция* означает, что группа связанных свойств, методов и других членов рассматривается как единый элемент или объект.</span><span class="sxs-lookup"><span data-stu-id="a79a0-107">*Encapsulation* means that a group of related properties, methods, and other members are treated as a single unit or object.</span></span>
- <span data-ttu-id="a79a0-108">*Наследование* описывает возможность создания новых классов на основе существующих классов.</span><span class="sxs-lookup"><span data-stu-id="a79a0-108">*Inheritance* describes the ability to create new classes based on an existing class.</span></span>
- <span data-ttu-id="a79a0-109">*Полиморфизм* означает, что можно иметь несколько взаимозаменяемых классов, даже если каждый класс реализует одни и те же свойства или методы разными способами.</span><span class="sxs-lookup"><span data-stu-id="a79a0-109">*Polymorphism* means that you can have multiple classes that can be used interchangeably, even though each class implements the same properties or methods in different ways.</span></span>

<span data-ttu-id="a79a0-110">Из предыдущего руководства с [общими сведениями о классах](introduction-to-classes.md) вы узнали об *абстракции* и *инкапсуляции*.</span><span class="sxs-lookup"><span data-stu-id="a79a0-110">In the preceding tutorial, [introduction to classes](introduction-to-classes.md) you saw both *abstraction* and *encapsulation*.</span></span> <span data-ttu-id="a79a0-111">Абстракция банковского счета реализована с помощью класса `BankAccount`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-111">The `BankAccount` class provided an abstraction for the concept of a bank account.</span></span> <span data-ttu-id="a79a0-112">Эту реализацию можно изменить, не влияя на код, в котором использовался класс `BankAccount`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-112">You could modify its implementation without affecting any of the code that used the `BankAccount` class.</span></span> <span data-ttu-id="a79a0-113">Классы `BankAccount` и `Transaction` позволяют реализовать инкапсуляцию компонентов, требуемых для описания этих концепций в коде.</span><span class="sxs-lookup"><span data-stu-id="a79a0-113">Both the `BankAccount` and `Transaction` classes provide encapsulation of the components needed to describe those concepts in code.</span></span>

<span data-ttu-id="a79a0-114">В этом руководстве показано, как расширить приложение, чтобы использовать *наследование* и *полиморфизм* для добавления новых функций.</span><span class="sxs-lookup"><span data-stu-id="a79a0-114">In this tutorial, you'll extend that application to make use of *inheritance* and *polymorphism* to add new features.</span></span> <span data-ttu-id="a79a0-115">Вы также добавите компоненты в класс `BankAccount`, чтобы использовать преимущества *абстракции* и *инкапсуляции*, о которых вы узнали при работе с предыдущим руководством.</span><span class="sxs-lookup"><span data-stu-id="a79a0-115">You'll also add features to the `BankAccount` class, taking advantage of the *abstraction* and *encapsulation* techniques you learned in the preceding tutorial.</span></span>

## <a name="create-different-types-of-accounts"></a><span data-ttu-id="a79a0-116">Создание разных типов счетов</span><span class="sxs-lookup"><span data-stu-id="a79a0-116">Create different types of accounts</span></span>

<span data-ttu-id="a79a0-117">После создания этой программы вы получите запросы на добавление в нее функций.</span><span class="sxs-lookup"><span data-stu-id="a79a0-117">After building this program, you get requests to add features to it.</span></span> <span data-ttu-id="a79a0-118">Это прекрасно работает в ситуации, когда у вас есть только один тип банковского счета.</span><span class="sxs-lookup"><span data-stu-id="a79a0-118">It works great in the situation where there is only one bank account type.</span></span> <span data-ttu-id="a79a0-119">С течением времени потребуется внести изменения, так как будут запрашиваться связанные типы счетов:</span><span class="sxs-lookup"><span data-stu-id="a79a0-119">Over time, needs change, and related account types are requested:</span></span>

- <span data-ttu-id="a79a0-120">Счет для начисления процентов в конце каждого месяца.</span><span class="sxs-lookup"><span data-stu-id="a79a0-120">An interest earning account that accrues interest at the end of each month.</span></span>
- <span data-ttu-id="a79a0-121">Кредитная линия, которая может иметь отрицательный баланс и с которой в этом случае ежемесячно взимаются проценты.</span><span class="sxs-lookup"><span data-stu-id="a79a0-121">A line of credit that can have a negative balance, but when there's a balance, there's an interest charge each month.</span></span>
- <span data-ttu-id="a79a0-122">Счет для предоплаченной подарочной карты с депозитом, используемый только для оплаты.</span><span class="sxs-lookup"><span data-stu-id="a79a0-122">A pre-paid gift card account that starts with a single deposit, and only can be paid off.</span></span> <span data-ttu-id="a79a0-123">Его можно пополнять один раз в начале каждого месяца.</span><span class="sxs-lookup"><span data-stu-id="a79a0-123">It can be refilled once at the start of each month.</span></span>

<span data-ttu-id="a79a0-124">Все эти счета можно реализовать с помощью класса `BankAccount`, определенного в предыдущем руководстве.</span><span class="sxs-lookup"><span data-stu-id="a79a0-124">All of these different accounts are similar to `BankAccount` class defined in the earlier tutorial.</span></span> <span data-ttu-id="a79a0-125">Можно скопировать этот код, переименовать классы и внести изменения.</span><span class="sxs-lookup"><span data-stu-id="a79a0-125">You could copy that code, rename the classes, and make modifications.</span></span> <span data-ttu-id="a79a0-126">Этот метод сработает в краткосрочной перспективе, но со временем ситуация усложнится.</span><span class="sxs-lookup"><span data-stu-id="a79a0-126">That technique would work in the short term, but it would be more work over time.</span></span> <span data-ttu-id="a79a0-127">Все изменения нужно будет копировать во все затронутые классы.</span><span class="sxs-lookup"><span data-stu-id="a79a0-127">Any changes would be copied across all the affected classes.</span></span>

<span data-ttu-id="a79a0-128">Вместо этого можно создать новые типы банковских счетов, которые наследуют методы и данные из класса `BankAccount`, созданного при работе с предыдущим руководством.</span><span class="sxs-lookup"><span data-stu-id="a79a0-128">Instead, you can create new bank account types that inherit methods and data from the `BankAccount` class created in the preceding tutorial.</span></span> <span data-ttu-id="a79a0-129">Эти новые классы могут расширить класс `BankAccount` за счет конкретного поведения, требуемого для каждого типа:</span><span class="sxs-lookup"><span data-stu-id="a79a0-129">These new classes can extend the `BankAccount` class with the specific behavior needed for each type:</span></span>

```csharp
public class InterestEarningAccount : BankAccount
{
}

public class LineOfCreditAccount : BankAccount
{
}

public class GiftCardAccount : BankAccount
{
}
```

<span data-ttu-id="a79a0-130">Каждый из этих классов *наследует* общее поведение общего *базового класса* `BankAccount`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-130">Each of these classes *inherits* the shared behavior from their shared *base class*, the `BankAccount` class.</span></span> <span data-ttu-id="a79a0-131">Напишите реализации новых отличающихся функций в каждом из *производных классов*.</span><span class="sxs-lookup"><span data-stu-id="a79a0-131">Write the implementations for new and different functionality in each of the *derived classes*.</span></span>  <span data-ttu-id="a79a0-132">Эти производные классы уже имеют поведение, определенное в классе `BankAccount`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-132">These derived classes already have all the behavior defined in the `BankAccount` class.</span></span>

<span data-ttu-id="a79a0-133">Рекомендуется создавать новый класс в другом исходном файле.</span><span class="sxs-lookup"><span data-stu-id="a79a0-133">It's a good practice to create each new class in a different source file.</span></span> <span data-ttu-id="a79a0-134">В [Visual Studio](https://visualstudio.com) можно щелкнуть правой кнопкой мыши проект и выбрать *Добавить класс*, чтобы добавить новый класс в новый файл.</span><span class="sxs-lookup"><span data-stu-id="a79a0-134">In [Visual Studio](https://visualstudio.com), you can right-click on the project, and select *add class* to add a new class in a new file.</span></span> <span data-ttu-id="a79a0-135">В [Visual Studio Code](https://code.visualstudio.com) выберите *Файл* и *Создать*, чтобы создать исходный файл.</span><span class="sxs-lookup"><span data-stu-id="a79a0-135">In [Visual Studio Code](https://code.visualstudio.com), select *File* then *New* to create a new source file.</span></span> <span data-ttu-id="a79a0-136">В любом из этих средств присвойте файлу имя, соответствующее имени класса: *InterestEarningAccount.cs*, *LineOfCreditAccount.cs* и *GiftCardAccount.cs*.</span><span class="sxs-lookup"><span data-stu-id="a79a0-136">In either tool, name the file to match the class: *InterestEarningAccount.cs*, *LineOfCreditAccount.cs*, and *GiftCardAccount.cs*.</span></span>

<span data-ttu-id="a79a0-137">При создании классов, как показано в примере выше, вы обнаружите, что ни один из производных классов не компилируется.</span><span class="sxs-lookup"><span data-stu-id="a79a0-137">When you create the classes as shown in the preceding sample, you'll find that none of your derived classes compile.</span></span> <span data-ttu-id="a79a0-138">За инициализацию объекта отвечает конструктор.</span><span class="sxs-lookup"><span data-stu-id="a79a0-138">A constructor is responsible for initializing an object.</span></span> <span data-ttu-id="a79a0-139">Конструктор производного класса должен инициализировать производный класс и предоставить инструкции по инициализации объекта базового класса, включенного в производный класс.</span><span class="sxs-lookup"><span data-stu-id="a79a0-139">A derived class constructor must initialize the derived class, and provide instructions on how to initialize the base class object included in the derived class.</span></span> <span data-ttu-id="a79a0-140">Правильная инициализация обычно выполняется без дополнительного кода.</span><span class="sxs-lookup"><span data-stu-id="a79a0-140">The proper initialization normally happens without any extra code.</span></span> <span data-ttu-id="a79a0-141">Класс `BankAccount` объявляет один открытый конструктор со следующей сигнатурой:</span><span class="sxs-lookup"><span data-stu-id="a79a0-141">The `BankAccount` class declares one public constructor with the following signature:</span></span>

```csharp
public BankAccount(string name, decimal initialBalance)
```

<span data-ttu-id="a79a0-142">Компилятор не создает конструктор по умолчанию при самостоятельном определении конструктора.</span><span class="sxs-lookup"><span data-stu-id="a79a0-142">The compiler doesn't generate a default constructor when you define a constructor yourself.</span></span> <span data-ttu-id="a79a0-143">Это означает, что каждый производный класс должен явно вызывать этот конструктор.</span><span class="sxs-lookup"><span data-stu-id="a79a0-143">That means each derived class must explicitly call this constructor.</span></span> <span data-ttu-id="a79a0-144">Вы объявляете конструктор, который может передавать аргументы конструктору базового класса.</span><span class="sxs-lookup"><span data-stu-id="a79a0-144">You declare a constructor that can pass arguments to the base class constructor.</span></span>  <span data-ttu-id="a79a0-145">В следующем коде показан конструктор для `InterestEarningAccount`:</span><span class="sxs-lookup"><span data-stu-id="a79a0-145">The following code shows the constructor for the `InterestEarningAccount`:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/InterestEarningAccount.cs" ID="DerivedConstructor":::

<span data-ttu-id="a79a0-146">Параметры для этого нового конструктора соответствуют типу и именам параметра конструктора базового класса.</span><span class="sxs-lookup"><span data-stu-id="a79a0-146">The parameters to this new constructor match the parameter type and names of the base class constructor.</span></span> <span data-ttu-id="a79a0-147">Для указания вызова конструктора базового класса используйте синтаксис `: base()`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-147">You use the `: base()` syntax to indicate a call to a base class constructor.</span></span> <span data-ttu-id="a79a0-148">Некоторые классы определяют несколько конструкторов, и этот синтаксис позволяет выбрать вызываемый конструктор базового класса.</span><span class="sxs-lookup"><span data-stu-id="a79a0-148">Some classes define multiple constructors, and this syntax enables you to pick which base class constructor you call.</span></span> <span data-ttu-id="a79a0-149">После обновления конструкторов можно разработать код для каждого производного класса.</span><span class="sxs-lookup"><span data-stu-id="a79a0-149">Once you've updated the constructors, you can develop the code for each of the derived classes.</span></span> <span data-ttu-id="a79a0-150">Требования к новым классам можно сформулировать следующим образом.</span><span class="sxs-lookup"><span data-stu-id="a79a0-150">The requirements for the new classes can be stated as follows:</span></span>

- <span data-ttu-id="a79a0-151">Счет для начисления процентов:</span><span class="sxs-lookup"><span data-stu-id="a79a0-151">An interest earning account:</span></span>
  - <span data-ttu-id="a79a0-152">Будут начисляться 2 % от текущего баланса в конце месяца.</span><span class="sxs-lookup"><span data-stu-id="a79a0-152">Will get a credit of 2% of the month-ending-balance.</span></span>
- <span data-ttu-id="a79a0-153">Кредитная линия:</span><span class="sxs-lookup"><span data-stu-id="a79a0-153">A line of credit:</span></span>
  - <span data-ttu-id="a79a0-154">Может иметь отрицательный баланс, который не превышает абсолютное значение кредитного лимита.</span><span class="sxs-lookup"><span data-stu-id="a79a0-154">Can have a negative balance, but not be greater in absolute value than the credit limit.</span></span>
  - <span data-ttu-id="a79a0-155">Будут списываться проценты каждый месяц, в конце которого баланс не равен 0.</span><span class="sxs-lookup"><span data-stu-id="a79a0-155">Will incur an interest charge each month where the end of month balance isn't 0.</span></span>
  - <span data-ttu-id="a79a0-156">Будет взиматься комиссия за каждый вывод средств, превышающий кредитный лимит.</span><span class="sxs-lookup"><span data-stu-id="a79a0-156">Will incur a fee on each withdrawal that goes over the credit limit.</span></span>
- <span data-ttu-id="a79a0-157">Счет для подарочной карты:</span><span class="sxs-lookup"><span data-stu-id="a79a0-157">A gift card account:</span></span>
  - <span data-ttu-id="a79a0-158">Может пополняться на указанную сумму в последний день каждого месяца.</span><span class="sxs-lookup"><span data-stu-id="a79a0-158">Can be refilled with a specified amount once each month, on the last day of the month.</span></span>

<span data-ttu-id="a79a0-159">Как видите, для каждого из этих типов счетов предусмотрено действие, которое выполняется в конце каждого месяца,</span><span class="sxs-lookup"><span data-stu-id="a79a0-159">You can see that all three of these account types have an action that takes places at the end of each month.</span></span> <span data-ttu-id="a79a0-160">и эти действия отличаются.</span><span class="sxs-lookup"><span data-stu-id="a79a0-160">However, each account type does different tasks.</span></span> <span data-ttu-id="a79a0-161">Для реализации этого кода используется *полиморфизм*.</span><span class="sxs-lookup"><span data-stu-id="a79a0-161">You use *polymorphism* to implement this code.</span></span> <span data-ttu-id="a79a0-162">Перейдите к методу `virtual` в классе `BankAccount`:</span><span class="sxs-lookup"><span data-stu-id="a79a0-162">Create a single `virtual` method in the `BankAccount` class:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/BankAccount.cs" ID="DeclareMonthEndTransactions":::

<span data-ttu-id="a79a0-163">В приведенном выше коде показано, как использовать ключевое слово `virtual` для объявления метода в базовом классе, для которого производный класс может предоставить другую реализацию.</span><span class="sxs-lookup"><span data-stu-id="a79a0-163">The preceding code shows how you use the `virtual` keyword to declare a method in the base class that a derived class may provide a different implementation for.</span></span> <span data-ttu-id="a79a0-164">`virtual` определяет метод, в котором любой производный класс может использовать повторную реализацию.</span><span class="sxs-lookup"><span data-stu-id="a79a0-164">A `virtual` method is a method where any derived class may choose to reimplement.</span></span> <span data-ttu-id="a79a0-165">Производные классы используют ключевое слово `override` для определения новой реализации.</span><span class="sxs-lookup"><span data-stu-id="a79a0-165">The derived classes use the `override` keyword to define the new implementation.</span></span> <span data-ttu-id="a79a0-166">Обычно это называется переопределением реализации базового класса.</span><span class="sxs-lookup"><span data-stu-id="a79a0-166">Typically you refer to this as "overriding the base class implementation".</span></span> <span data-ttu-id="a79a0-167">Ключевое слово `virtual` указывает, что производные классы могут переопределить поведение.</span><span class="sxs-lookup"><span data-stu-id="a79a0-167">The `virtual` keyword specifies that derived classes may override the behavior.</span></span> <span data-ttu-id="a79a0-168">Вы также можете объявить методы `abstract`, где производные классы должны переопределять поведение.</span><span class="sxs-lookup"><span data-stu-id="a79a0-168">You can also declare `abstract` methods where derived classes must override the behavior.</span></span> <span data-ttu-id="a79a0-169">Базовый класс не предоставляет реализацию для метода `abstract`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-169">The base class does not provide an implementation for an `abstract` method.</span></span> <span data-ttu-id="a79a0-170">Далее необходимо определить реализацию для двух новых классов, которые вы создали.</span><span class="sxs-lookup"><span data-stu-id="a79a0-170">Next, you need to define the implementation for two of the new classes you've created.</span></span> <span data-ttu-id="a79a0-171">Начните с `InterestEarningAccount`:</span><span class="sxs-lookup"><span data-stu-id="a79a0-171">Start with the `InterestEarningAccount`:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/InterestEarningAccount.cs" ID="ApplyMonthendInterest":::

<span data-ttu-id="a79a0-172">Добавьте следующий код в `LineOfCreditAccount`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-172">Add the following code to the `LineOfCreditAccount`.</span></span> <span data-ttu-id="a79a0-173">Код обнуляет баланс для расчета положительной процентной ставки, снятой со счета:</span><span class="sxs-lookup"><span data-stu-id="a79a0-173">The code negates the balance to compute a positive interest charge that is withdrawn from the account:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/LineOfCreditAccount.cs" ID="ApplyMonthendInterest":::

<span data-ttu-id="a79a0-174">Классу `GiftCardAccount` требуются два изменения, чтобы реализовать соответствующее действие, выполняемое в конце месяца.</span><span class="sxs-lookup"><span data-stu-id="a79a0-174">The `GiftCardAccount` class needs two changes to implement its month-end functionality.</span></span> <span data-ttu-id="a79a0-175">Во-первых, измените конструктор, включив в него дополнительную сумму, добавляемую ежемесячно:</span><span class="sxs-lookup"><span data-stu-id="a79a0-175">First, modify the constructor to include an optional amount to add each month:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/GiftCardAccount.cs" ID="GiftCardAccountConstruction":::

<span data-ttu-id="a79a0-176">Конструктор предоставляет значение по умолчанию для значения `monthlyDeposit`, поэтому вызывающие объекты могут опускать `0` при отсутствии ежемесячного депозита.</span><span class="sxs-lookup"><span data-stu-id="a79a0-176">The constructor provides a default value for the `monthlyDeposit` value so callers can omit a `0` for no monthly deposit.</span></span> <span data-ttu-id="a79a0-177">Во-вторых, переопределите метод `PerformMonthEndTransactions`, чтобы добавить месячный депозит, если в конструкторе было задано ненулевое значение:</span><span class="sxs-lookup"><span data-stu-id="a79a0-177">Next, override the `PerformMonthEndTransactions` method to add the monthly deposit, if it was set to a non-zero value in the constructor:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/GiftCardAccount.cs" ID="AddMonthlyDeposit":::

<span data-ttu-id="a79a0-178">Переопределение применяет набор месячных депозитов в конструкторе.</span><span class="sxs-lookup"><span data-stu-id="a79a0-178">The override applies the monthly deposit set in the constructor.</span></span> <span data-ttu-id="a79a0-179">Добавьте следующий код в метод `Main`, чтобы проверить эти изменения для `GiftCardAccount` и `InterestEarningAccount`:</span><span class="sxs-lookup"><span data-stu-id="a79a0-179">Add the following code to the `Main` method to test these changes for the `GiftCardAccount` and the `InterestEarningAccount`:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/Program.cs" ID="FirstTests":::

<span data-ttu-id="a79a0-180">Проверьте результаты.</span><span class="sxs-lookup"><span data-stu-id="a79a0-180">Verify the results.</span></span> <span data-ttu-id="a79a0-181">Теперь добавьте аналогичный набор тестового кода для `LineOfCreditAccount`:</span><span class="sxs-lookup"><span data-stu-id="a79a0-181">Now, add a similar set of test code for the `LineOfCreditAccount`:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/Program.cs" ID="TestLineOfCredit":::

<span data-ttu-id="a79a0-182">Когда вы добавите приведенный выше код и запустите программу, вы увидите примерно такую ошибку:</span><span class="sxs-lookup"><span data-stu-id="a79a0-182">When you add the preceding code and run the program, you'll see something like the following error:</span></span>

```console
Unhandled exception. System.ArgumentOutOfRangeException: Amount of deposit must be positive (Parameter 'amount')
   at OOProgramming.BankAccount.MakeDeposit(Decimal amount, DateTime date, String note) in BankAccount.cs:line 42
   at OOProgramming.BankAccount..ctor(String name, Decimal initialBalance) in BankAccount.cs:line 31
   at OOProgramming.LineOfCreditAccount..ctor(String name, Decimal initialBalance) in LineOfCreditAccount.cs:line 9
   at OOProgramming.Program.Main(String[] args) in Program.cs:line 29
```

> [!NOTE]
> <span data-ttu-id="a79a0-183">Фактический результат включает полный путь к папке с проектом.</span><span class="sxs-lookup"><span data-stu-id="a79a0-183">The actual output includes the full path to the folder with the project.</span></span> <span data-ttu-id="a79a0-184">Имена папок опущены для краткости.</span><span class="sxs-lookup"><span data-stu-id="a79a0-184">The folder names were omitted for brevity.</span></span> <span data-ttu-id="a79a0-185">Кроме того, в зависимости от формата кода номера строк могут отличаться.</span><span class="sxs-lookup"><span data-stu-id="a79a0-185">Also, depending on your code format, the line numbers may be slightly different.</span></span>

<span data-ttu-id="a79a0-186">Этот код завершается ошибкой, так как в `BankAccount` предполагается, что исходный баланс должен быть больше 0.</span><span class="sxs-lookup"><span data-stu-id="a79a0-186">This code fails because the `BankAccount` assumes that the initial balance must be greater than 0.</span></span> <span data-ttu-id="a79a0-187">Еще одно допущение, реализованное в классе `BankAccount`, заключается в том, что баланс не может быть отрицательным.</span><span class="sxs-lookup"><span data-stu-id="a79a0-187">Another assumption baked into the `BankAccount` class is that the balance can't go negative.</span></span> <span data-ttu-id="a79a0-188">Вместо этого любой вывод средств, превышающий сумму на счете, отклоняется.</span><span class="sxs-lookup"><span data-stu-id="a79a0-188">Instead, any withdrawal that overdraws the account is rejected.</span></span> <span data-ttu-id="a79a0-189">Оба эти предположения необходимо изменить.</span><span class="sxs-lookup"><span data-stu-id="a79a0-189">Both of those assumptions need to change.</span></span> <span data-ttu-id="a79a0-190">Баланс кредитного счета равен 0 и, как правило, в дальнейшем будет иметь отрицательное значение.</span><span class="sxs-lookup"><span data-stu-id="a79a0-190">The line of credit account starts at 0, and generally will have a negative balance.</span></span> <span data-ttu-id="a79a0-191">Кроме того, если клиент займет слишком много денег, с него будет списана комиссия.</span><span class="sxs-lookup"><span data-stu-id="a79a0-191">Also, if a customer borrows too much money, they incur a fee.</span></span> <span data-ttu-id="a79a0-192">Транзакция принимается, она просто требует дополнительных затрат.</span><span class="sxs-lookup"><span data-stu-id="a79a0-192">The transaction is accepted, it just costs more.</span></span> <span data-ttu-id="a79a0-193">Первое правило можно реализовать, добавив необязательный аргумент к конструктору `BankAccount`, который определяет минимальный баланс.</span><span class="sxs-lookup"><span data-stu-id="a79a0-193">The first rule can be implemented by adding an optional argument to the `BankAccount` constructor that specifies the minimum balance.</span></span> <span data-ttu-id="a79a0-194">Значение по умолчанию — `0`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-194">The default is `0`.</span></span> <span data-ttu-id="a79a0-195">Для второго правила требуется механизм, который позволяет производным классам изменять алгоритм по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="a79a0-195">The second rule requires a mechanism that enables derived classes to modify the default algorithm.</span></span> <span data-ttu-id="a79a0-196">В некотором смысле базовый класс уточняет у производного типа, что должно произойти при перерасходе.</span><span class="sxs-lookup"><span data-stu-id="a79a0-196">In a sense, the base class "asks" the derived type what should happen when there's an overdraft.</span></span> <span data-ttu-id="a79a0-197">Поведение по умолчанию — отклонить транзакцию, вызвав исключение.</span><span class="sxs-lookup"><span data-stu-id="a79a0-197">The default behavior is to reject the transaction by throwing an exception.</span></span>

<span data-ttu-id="a79a0-198">Начнем с добавления второго конструктора, который включает необязательный параметр `minimumBalance`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-198">Let's start by adding a second constructor that includes an optional `minimumBalance` parameter.</span></span> <span data-ttu-id="a79a0-199">Этот новый конструктор выполняет все действия, выполняемые существующим конструктором.</span><span class="sxs-lookup"><span data-stu-id="a79a0-199">This new constructor does all the actions done by the existing constructor.</span></span> <span data-ttu-id="a79a0-200">Кроме того, задается свойство, определяющее минимальный баланс.</span><span class="sxs-lookup"><span data-stu-id="a79a0-200">Also, it sets the minimum balance property.</span></span> <span data-ttu-id="a79a0-201">Вы можете скопировать текст существующего конструктора,</span><span class="sxs-lookup"><span data-stu-id="a79a0-201">You could copy the body of the existing constructor.</span></span> <span data-ttu-id="a79a0-202">но это означает, что в будущем нужно будет изменить два расположения.</span><span class="sxs-lookup"><span data-stu-id="a79a0-202">but that means two locations to change in the future.</span></span> <span data-ttu-id="a79a0-203">Вместо этого можно использовать *цепочки конструкторов*, чтобы один конструктор вызывал другой.</span><span class="sxs-lookup"><span data-stu-id="a79a0-203">Instead, you can use *constructor chaining* to have one constructor call another.</span></span> <span data-ttu-id="a79a0-204">В следующем коде показаны два конструктора и новое дополнительное поле:</span><span class="sxs-lookup"><span data-stu-id="a79a0-204">The following code shows the two constructors and the new additional field:</span></span>

 :::code language="csharp" source="./snippets/object-oriented-programming/BankAccount.cs" ID="ConstructorModifications":::

<span data-ttu-id="a79a0-205">В приведенном выше коде показаны два новых метода.</span><span class="sxs-lookup"><span data-stu-id="a79a0-205">The preceding code shows two new techniques.</span></span> <span data-ttu-id="a79a0-206">Во-первых, поле `minimumBalance` помечается как `readonly`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-206">First, the `minimumBalance` field is marked as `readonly`.</span></span> <span data-ttu-id="a79a0-207">Это означает, что значение нельзя изменить после создания объекта.</span><span class="sxs-lookup"><span data-stu-id="a79a0-207">That means the value cannot be changed after the object is constructed.</span></span> <span data-ttu-id="a79a0-208">После создания `BankAccount` `minimumBalance` не может измениться.</span><span class="sxs-lookup"><span data-stu-id="a79a0-208">Once a `BankAccount` is created, the `minimumBalance` can't change.</span></span> <span data-ttu-id="a79a0-209">Во вторых, конструктор, принимающий два параметра, использует `: this(name, initialBalance, 0) { }` в качестве реализации.</span><span class="sxs-lookup"><span data-stu-id="a79a0-209">Second, the constructor that takes two parameters uses `: this(name, initialBalance, 0) { }` as its implementation.</span></span> <span data-ttu-id="a79a0-210">Выражение `: this()` вызывает другой конструктор, который имеет три параметра.</span><span class="sxs-lookup"><span data-stu-id="a79a0-210">The `: this()` expression calls the other constructor, the one with three parameters.</span></span> <span data-ttu-id="a79a0-211">Этот метод позволяет применить одну реализацию для инициализации объекта, даже несмотря на то, что клиентский код может выбрать один из многих конструкторов.</span><span class="sxs-lookup"><span data-stu-id="a79a0-211">This technique allows you to have a single implementation for initializing an object even though client code can choose one of many constructors.</span></span>

<span data-ttu-id="a79a0-212">Эта реализация вызывает `MakeDeposit`, только если исходный баланс превышает `0`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-212">This implementation calls `MakeDeposit` only if the initial balance is greater than `0`.</span></span> <span data-ttu-id="a79a0-213">Таким образом, мы придерживаемся правила, согласно которого депозиты должны быть положительными, а кредитный счет открывается с балансом, равным `0`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-213">That preserves the rule that deposits must be positive, yet lets the credit account open with a `0` balance.</span></span>

<span data-ttu-id="a79a0-214">Теперь, когда класс `BankAccount` имеет доступное только для чтения поле для определения минимального баланса, последнее изменение заключается в изменении прописанного в коде значения `0` на `minimumBalance` в методе `MakeWithdrawal`:</span><span class="sxs-lookup"><span data-stu-id="a79a0-214">Now that the `BankAccount` class has a read-only field for the minimum balance, the final change is to change the hard code `0` to `minimumBalance` in the `MakeWithdrawal` method:</span></span>

```csharp
if (Balance - amount < minimumBalance)
```

<span data-ttu-id="a79a0-215">После расширения класса `BankAccount` можно изменить конструктор `LineOfCreditAccount`, чтобы вызвать новый базовый конструктор, как показано в следующем коде:</span><span class="sxs-lookup"><span data-stu-id="a79a0-215">After extending the `BankAccount` class, you can modify the `LineOfCreditAccount` constructor to call the new base constructor, as shown in the following code:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/LineOfCreditAccount.cs" ID="ConstructLineOfCredit":::

<span data-ttu-id="a79a0-216">Обратите внимание, что конструктор `LineOfCreditAccount` изменяет знак параметра `creditLimit`, чтобы он соответствовал значению параметра `minimumBalance`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-216">Notice that the `LineOfCreditAccount` constructor changes the sign of the `creditLimit` parameter so it matches the meaning of the `minimumBalance` parameter.</span></span>

## <a name="different-overdraft-rules"></a><span data-ttu-id="a79a0-217">Разные правила, связанные с перерасходом</span><span class="sxs-lookup"><span data-stu-id="a79a0-217">Different overdraft rules</span></span>

<span data-ttu-id="a79a0-218">Последняя добавляемая функция позволяет `LineOfCreditAccount` взимать комиссию за превышение кредитного лимита вместо того, чтобы отклонять транзакцию.</span><span class="sxs-lookup"><span data-stu-id="a79a0-218">The last feature to add enables the `LineOfCreditAccount` to charge a fee for going over the credit limit instead of refusing the transaction.</span></span>

<span data-ttu-id="a79a0-219">Для этого можно, например, определить виртуальную функцию, в которой реализуется требуемое поведение.</span><span class="sxs-lookup"><span data-stu-id="a79a0-219">One technique is to define a virtual function where you implement the required behavior.</span></span> <span data-ttu-id="a79a0-220">Класс `Bank Account` выполняет рефакторинг метода `MakeWithdrawal`, чтобы получить два метода.</span><span class="sxs-lookup"><span data-stu-id="a79a0-220">The `Bank Account` class refactors the `MakeWithdrawal` method into two methods.</span></span> <span data-ttu-id="a79a0-221">Новый метод выполняет указанное действие, когда при выводе средств баланс получает значение ниже определенного минимума.</span><span class="sxs-lookup"><span data-stu-id="a79a0-221">The new method does the specified action when the withdrawal takes the balance below the minimum.</span></span> <span data-ttu-id="a79a0-222">Существующий метод `MakeWithdrawal` имеет следующий код:</span><span class="sxs-lookup"><span data-stu-id="a79a0-222">The existing `MakeWithdrawal` method has the following code:</span></span>

```csharp
public void MakeWithdrawal(decimal amount, DateTime date, string note)
{
    if (amount <= 0)
    {
        throw new ArgumentOutOfRangeException(nameof(amount), "Amount of withdrawal must be positive");
    }
    if (Balance - amount < minimumBalance)
    {
        throw new InvalidOperationException("Not sufficient funds for this withdrawal");
    }
    var withdrawal = new Transaction(-amount, date, note);
    allTransactions.Add(withdrawal);
}
```

<span data-ttu-id="a79a0-223">Замените его следующим кодом.</span><span class="sxs-lookup"><span data-stu-id="a79a0-223">Replace it with the following code:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/BankAccount.cs" ID="RefactoredMakeWithdrawal":::

<span data-ttu-id="a79a0-224">Добавленный метод `protected` предполагает, что его можно вызывать только из производных классов.</span><span class="sxs-lookup"><span data-stu-id="a79a0-224">The added method is `protected`, which means that it can be called only from derived classes.</span></span> <span data-ttu-id="a79a0-225">Это объявление предотвращает вызов метода другими клиентами.</span><span class="sxs-lookup"><span data-stu-id="a79a0-225">That declaration prevents other clients from calling the method.</span></span> <span data-ttu-id="a79a0-226">А ключевое слово `virtual` означает, что производные классы могут изменять поведение.</span><span class="sxs-lookup"><span data-stu-id="a79a0-226">It's also `virtual` so that derived classes can change the behavior.</span></span> <span data-ttu-id="a79a0-227">Тип возвращаемого значения — `Transaction?`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-227">The return type is a `Transaction?`.</span></span> <span data-ttu-id="a79a0-228">Аннотация `?` указывает, что метод может возвращать `null`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-228">The `?` annotation indicates that the method may return `null`.</span></span> <span data-ttu-id="a79a0-229">Добавьте следующую реализацию в `LineOfCreditAccount`, чтобы списывать комиссию при превышении лимита на вывод средств.</span><span class="sxs-lookup"><span data-stu-id="a79a0-229">Add the following implementation in the `LineOfCreditAccount` to charge a fee when the withdrawal limit is exceeded:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/LineOfCreditAccount.cs" ID="AddOverdraftFee":::

<span data-ttu-id="a79a0-230">В этом случае переопределение возвращает транзакцию с комиссией.</span><span class="sxs-lookup"><span data-stu-id="a79a0-230">The override returns a fee transaction when the account is overdrawn.</span></span> <span data-ttu-id="a79a0-231">Если при выводе средств лимит не превышен, метод возвращает транзакцию `null`.</span><span class="sxs-lookup"><span data-stu-id="a79a0-231">If the withdrawal doesn't go over the limit, the method returns a `null` transaction.</span></span> <span data-ttu-id="a79a0-232">Это означает, что комиссия не взимается.</span><span class="sxs-lookup"><span data-stu-id="a79a0-232">That indicates there's no fee.</span></span> <span data-ttu-id="a79a0-233">Чтобы проверить эти изменения, добавьте следующий код в метод `Main` в классе `Program`:</span><span class="sxs-lookup"><span data-stu-id="a79a0-233">Test these changes by adding the following code to your `Main` method in the `Program` class:</span></span>

:::code language="csharp" source="./snippets/object-oriented-programming/Program.cs" ID="TestLineOfCredit":::

<span data-ttu-id="a79a0-234">Запустите программу и проверьте результаты.</span><span class="sxs-lookup"><span data-stu-id="a79a0-234">Run the program, and check the results.</span></span>

## <a name="summary"></a><span data-ttu-id="a79a0-235">Сводка</span><span class="sxs-lookup"><span data-stu-id="a79a0-235">Summary</span></span>

<span data-ttu-id="a79a0-236">В этом руководстве показаны разные методы, используемые в объектно-ориентированном программировании:</span><span class="sxs-lookup"><span data-stu-id="a79a0-236">This tutorial demonstrated many of the techniques used in Object-Oriented programming:</span></span>

- <span data-ttu-id="a79a0-237">Вы использовали *абстракции*, когда сохраняли в каждом классе много сведений (`private`).</span><span class="sxs-lookup"><span data-stu-id="a79a0-237">You used *Abstraction* when you kept many details `private` in each class.</span></span>
- <span data-ttu-id="a79a0-238">Вы использовали *инкапсуляцию*, когда определяли классы для каждого из типов счетов.</span><span class="sxs-lookup"><span data-stu-id="a79a0-238">You used *Encapsulation* when you defined classes for each of the different account types.</span></span> <span data-ttu-id="a79a0-239">Эти классы описывали поведение для каждого типа счета.</span><span class="sxs-lookup"><span data-stu-id="a79a0-239">Those classes described the behavior for that type of account.</span></span>
- <span data-ttu-id="a79a0-240">Вы использовали *наследование*, когда применяли реализацию, уже созданную в классе `BankAccount` для сохранения кода.</span><span class="sxs-lookup"><span data-stu-id="a79a0-240">You used *Inheritance* when you leveraged the implementation already created in the `BankAccount` class to save code.</span></span>
- <span data-ttu-id="a79a0-241">Вы использовали *полиморфизм*, когда создавали методы `virtual`, которые производные классы могут переопределить для создания определенного поведения для этого типа счета.</span><span class="sxs-lookup"><span data-stu-id="a79a0-241">You used *Polymorphism* when you created `virtual` methods that derived classes could override to create specific behavior for that account type.</span></span>

<span data-ttu-id="a79a0-242">Поздравляем! Вы завершили работу с циклом вводных руководств по C#.</span><span class="sxs-lookup"><span data-stu-id="a79a0-242">Congratulations, you've finished all of our introduction to C# tutorials.</span></span> <span data-ttu-id="a79a0-243">Чтобы узнать больше, ознакомьтесь с другими [руководствами](../index.md).</span><span class="sxs-lookup"><span data-stu-id="a79a0-243">To learn more, try more of our [tutorials](../index.md).</span></span>
