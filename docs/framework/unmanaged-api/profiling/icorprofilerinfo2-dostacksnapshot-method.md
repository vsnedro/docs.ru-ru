---
title: Метод ICorProfilerInfo2::DoStackSnapshot
ms.date: 03/30/2017
api_name:
- ICorProfilerInfo2.DoStackSnapshot
api_location:
- mscorwks.dll
api_type:
- COM
f1_keywords:
- ICorProfilerInfo2::DoStackSnapshot
helpviewer_keywords:
- ICorProfilerInfo2::DoStackSnapshot method [.NET Framework profiling]
- DoStackSnapshot method [.NET Framework profiling]
ms.assetid: 287b11e9-7c52-4a13-ba97-751203fa97f4
topic_type:
- apiref
ms.openlocfilehash: b9a7142de01d818390b740a795f70a4606952780
ms.sourcegitcommit: da21fc5a8cce1e028575acf31974681a1bc5aeed
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/08/2020
ms.locfileid: "84497378"
---
# <a name="icorprofilerinfo2dostacksnapshot-method"></a>Метод ICorProfilerInfo2::DoStackSnapshot
Просматривает управляемые кадры в стеке для указанного потока и отправляет сведения профилировщику через обратный вызов.  
  
## <a name="syntax"></a>Синтаксис  
  
```cpp  
HRESULT DoStackSnapshot(  
    [in] ThreadID thread,  
    [in] StackSnapshotCallback *callback,  
    [in] ULONG32 infoFlags,  
    [in] void *clientData,  
    [in, size_is(contextSize), length_is(contextSize)] BYTE context[],  
    [in] ULONG32 contextSize);  
```  
  
## <a name="parameters"></a>Параметры  
 `thread`  
 окне Идентификатор целевого потока.  
  
 При передаче значения NULL в `thread` получается моментальный снимок текущего потока. Если `ThreadID` передается другой поток, среда CLR приостанавливает этот поток, выполняет моментальный снимок и возобновляет работу.  
  
 `callback`  
 окне Указатель на реализацию метода [стаккснапшоткаллбакк](stacksnapshotcallback-function.md) , который ВЫЗЫВАЕТся средой CLR для предоставления профилировщику сведений о каждом управляемом кадре и каждом запуске неуправляемых фреймов.  
  
 `StackSnapshotCallback`Метод реализуется модулем записи профилировщика.  
  
 `infoFlags`  
 окне Значение перечисления [COR_PRF_SNAPSHOT_INFO](cor-prf-snapshot-info-enumeration.md) , которое указывает объем данных, которые необходимо передать обратно для каждого кадра `StackSnapshotCallback` .  
  
 `clientData`  
 окне Указатель на клиентские данные, которые передаются непосредственно в `StackSnapshotCallback` функцию обратного вызова.  
  
 `context`  
 окне Указатель на `CONTEXT` структуру Win32, которая используется для заполнения прохода стека. Структура Win32 `CONTEXT` содержит значения регистров ЦП и представляет состояние ЦП в определенный момент времени.  
  
 Начальное значение помогает среде CLR определить, где следует начать анализ стека, если вершина стека является неуправляемым вспомогательным кодом. в противном случае начальное значение игнорируется. Для асинхронного прохода необходимо указать начальное значение. При выполнении синхронного анализа начальное значение не требуется.  
  
 `context`Параметр допустим только в том случае, если в параметре был передан флаг COR_PRF_SNAPSHOT_CONTEXT `infoFlags` .  
  
 `contextSize`  
 окне Размер `CONTEXT` структуры, на которую ссылается `context` параметр.  
  
## <a name="remarks"></a>Примечания  
 При передаче значения NULL для `thread` получается моментальный снимок текущего потока. Моментальные снимки могут создаваться для других потоков, только если целевой поток приостановлен в данный момент времени.  
  
 Когда профилировщик хочет пройти по стеку, он вызывает `DoStackSnapshot` . Перед возвратом из этого вызова среда CLR вызывает `StackSnapshotCallback` несколько раз, один раз для каждого управляемого кадра (или для запуска неуправляемых фреймов) в стеке. При обнаружении неуправляемых кадров их необходимо проанализировать самостоятельно.  
  
 Порядок, в котором выполняется продвижение стека, — это обратная процедура, с которой кадры помещаются в стек: первый кадр (последний отправленный), основной кадр (с первой передачей) последним.  
  
 Дополнительные сведения о программировании профилировщика для прохода по управляемым стекам см. в статьях анализ [стека профилировщика в .NET Framework 2,0: основы и больше](https://docs.microsoft.com/previous-versions/dotnet/articles/bb264782(v=msdn.10)).  
  
 Анализ стека может быть синхронным или асинхронным, как описано в следующих разделах.  
  
## <a name="synchronous-stack-walk"></a>Синхронный анализ стека  
 Синхронный анализ стека включает в себя проход стека текущего потока в ответ на обратный вызов. Для этого не требуется заполнение или приостановка.  
  
 Синхронный вызов выполняется, когда в ответ на CLR, вызывающий один из методов [ICorProfilerCallback](icorprofilercallback-interface.md) (или [ICorProfilerCallback2](icorprofilercallback2-interface.md)) профилировщика, вызывается `DoStackSnapshot` для прохода по стеку текущего потока. Это полезно, если нужно увидеть, как выглядит стек на уведомлении, например, с помощью [ICorProfilerCallback:: ObjectAllocated](icorprofilercallback-objectallocated-method.md). Вы просто вызываете в `DoStackSnapshot` `ICorProfilerCallback` методе, передавая NULL в `context` `thread` параметрах и.  
  
## <a name="asynchronous-stack-walk"></a>Асинхронный анализ стека  
 Асинхронный проход стека включает в себя проход стека другого потока или проход стека текущего потока, а не в ответ на обратный вызов, но путем захвата указателя инструкций текущего потока. Асинхронный проход требует начального значения, если вершина стека является неуправляемым кодом, который не является частью вызова неуправляемого кода (PInvoke) или вызовов COM, но вспомогательный код в самой среде CLR. Например, код, выполняющий JIT-компиляцию или сборку мусора, является вспомогательным кодом.  
  
 Вы получаете начальное значение, напрямую приостанавливая целевой поток и проследуя его стек, пока не найдете самый верхний управляемый фрейм. После приостановки целевого потока получите текущий контекст регистров целевого потока. Затем определите, указывает ли контекст регистра на неуправляемый код, вызвав [ICorProfilerInfo:: GetFunctionFromIP](icorprofilerinfo-getfunctionfromip-method.md) — если он возвращает значение `FunctionID` , равное нулю, кадр является неуправляемым кодом. Теперь пройдите по стеку, пока не дойдете до первого управляемого фрейма, а затем вычислите контекст начального значения в зависимости от контекста регистров для этого кадра.  
  
 Вызовите его `DoStackSnapshot` с контекстом начального значения, чтобы начать асинхронный обход стека. Если не указать начальное значение, `DoStackSnapshot` может пропускать управляемые фреймы в верхней части стека и, следовательно, выдаст вам неполную проверку стека. Если указать начальное значение, оно должно указывать на JIT-скомпилированный или генератор образов в машинном коде (Ngen. exe), созданный кодом; в противном случае `DoStackSnapshot` возвращает код ошибки CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX.  
  
 Асинхронные проверки стека могут привести к взаимоблокировкам или нарушениям доступа, если не следовать приведенным ниже рекомендациям.  
  
- При прямой приостановке потоков Помните, что только поток, который никогда не выполнял управляемый код, может приостановить другой поток.  
  
- Всегда заблокируйте в обратном вызове [ICorProfilerCallback:: ThreadDestroyed](icorprofilercallback-threaddestroyed-method.md) , пока не завершится проверка стека этого потока.  
  
- Не держите блокировку во время вызова профилировщика в функцию CLR, которая может активировать сборку мусора. Это значит, что блокировка не удерживается, если владеющий поток может выполнить вызов, который активирует сборку мусора.  
  
 Кроме того, существует риск взаимоблокировки при вызове `DoStackSnapshot` из потока, созданного профилировщиком, чтобы можно было проанализировать стек отдельного целевого потока. В первый раз, когда созданный поток вводит определенные `ICorProfilerInfo*` методы (включая `DoStackSnapshot` ), среда CLR выполнит для этого потока инициализацию, зависящую от среды CLR, для каждого потока. Если профилировщик приостановил целевой поток, стек которого вы пытаетесь проанализировать, и если этот целевой поток был владельцем блокировки, необходимой для выполнения этой инициализации для каждого потока, произойдет взаимоблокировка. Чтобы избежать этой взаимоблокировки, сделайте начальный вызов `DoStackSnapshot` из потока, созданного профилировщиком, для прохода по отдельному целевому потоку, но сначала не приостанавливаете целевой поток. Этот начальный вызов гарантирует, что инициализация для каждого потока может завершиться без взаимоблокировки. Если `DoStackSnapshot` в случае успешности и сообщает по крайней мере один кадр, после этой точки он будет защищен для этого потока, созданного профилировщиком, для приостановки любого целевого потока и вызова `DoStackSnapshot` для прохода стека этого целевого потока.  
  
## <a name="requirements"></a>Требования  
 **Платформы:** см. раздел [Требования к системе](../../get-started/system-requirements.md).  
  
 **Заголовок:** CorProf.idl, CorProf.h  
  
 **Библиотека:** CorGuids.lib  
  
 **.NET Framework версии:**[!INCLUDE[net_current_v20plus](../../../../includes/net-current-v20plus-md.md)]  
  
## <a name="see-also"></a>См. также

- [Интерфейс ICorProfilerInfo](icorprofilerinfo-interface.md)
- [Интерфейс ICorProfilerInfo2](icorprofilerinfo2-interface.md)
