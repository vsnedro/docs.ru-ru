---
title: Синхронные сценарии с использованием HTTP, TCP или именованного канала
ms.date: 03/30/2017
ms.assetid: 7e90af1b-f8f6-41b9-a63a-8490ada502b1
ms.openlocfilehash: 662067fc5564c9421ce24b28b291d06690b129ea
ms.sourcegitcommit: cdb295dd1db589ce5169ac9ff096f01fd0c2da9d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2020
ms.locfileid: "84589188"
---
# <a name="synchronous-scenarios-using-http-tcp-or-named-pipe"></a>Синхронные сценарии с использованием HTTP, TCP или именованного канала
В этом разделе описываются действия и перенаправления для различных сценариев синхронных запросов/ответов (с однопотоковым клиентом, с использованием HTTP, TCP или именованного канала). Дополнительные сведения о многопоточных запросах см. в статье [асинхронные сценарии с использованием HTTP, TCP или именованного канала](asynchronous-scenarios-using-http-tcp-or-named-pipe.md) .  
  
## <a name="synchronous-requestreply-without-errors"></a>Синхронный запрос/ответ без ошибок  
 В этом разделе описываются действия и перенаправления для реального сценария синхронных запросов/ответов (с однопотоковым клиентом).  
  
### <a name="client"></a>Клиент  
  
#### <a name="establishing-communication-with-service-endpoint"></a>Установка связи с конечной точкой службы  
 Создается и открывается клиент. Для каждого из этих шагов внешнее действие (A) передается в действие "конструировать клиент" (B) и "открыть клиент" (C) соответственно. Для каждого действия, которому оно перенаправляется, внешнее действие приостанавливается до момента обратного перенаправления (т. е. до выполнения кода ServiceModel).  
  
#### <a name="making-a-request-to-service-endpoint"></a>Создание запроса для конечной точки службы  
 Внешнее действие передается в действие "ProcessAction" (D). В рамках этого действия отправляется сообщение запроса и принимается сообщение ответа. Действие прекращается, когда управление возвращается пользовательскому коду. Поскольку этот запрос является синхронным, внешнее действие приостанавливается до возврата управления.  
  
#### <a name="closing-communication-with-service-endpoint"></a>Закрытие связи с конечной точкой службы  
 Действие «закрыть» (I) клиента создается из внешнего действия. Оно идентично действиям "создать" и "открыть".  
  
### <a name="server"></a>Сервер  
  
#### <a name="setting-up-a-service-host"></a>Настройка узла службы  
 Действия «создать» и «открыть» (N и O) узла ServiceHost создаются из внешнего действия (M).  
  
 Действие прослушивания (P) создается при открывании узла ServiceHost для каждого прослушивателя. Действие прослушивания ожидает получения и обработки данных.  
  
#### <a name="receiving-data-on-the-wire"></a>Получение данных по сети  
 Когда данные поступают на канал, создается действие "Рецеивебитес", если оно еще не существует (Q) для обработки полученных данных. Это действие можно использовать повторно для нескольких сообщений в пределах одного соединения или очереди.  
  
 Действие ReceiveBytes запускает действие ProcessMessage (R) при наличии достаточной информации для формирования сообщения действия SOAP.  
  
 При действии R обрабатываются заголовки сообщений и проверяется заголовок activityID. Если этот заголовок имеется, идентификатору действия присваивается значение ProcessAction. В противном случае создается новый идентификатор.  
  
 При обработке вызова создается действие ProcessAction (S), и выполняется перенаправление на это действие. Данное действие завершается при полном завершении обработки, связанной с входящим сообщением, включая выполнение пользовательского кода (T) и отправку ответного сообщения (если она предусмотрена).  
  
#### <a name="closing-a-service-host"></a>Закрытие узла службы  
 Действие "закрыть" (Z) узла ServiceHost создается из внешнего действия.  
  
 ![Диаграмма, на которой показаны Синхронные сценарии: HTTP, TCP или именованные каналы.](./media/synchronous-scenarios-using-http-tcp-or-named-pipe/synchronous-scenario-http-tcp-named-pipes.gif)  
  
 В \<A: name> `A` — это символ ярлыка, описывающий действие в предыдущем тексте и в таблице 3. `Name` представляет собой сокращенное имя действия.  
  
 Если значение `propagateActivity` = `true` равно, действие обработки для клиента и службы имеют одинаковый идентификатор действия.  
  
## <a name="synchronous-requestreply-with-errors"></a>Синхронный запрос/ответ с ошибками  
 Единственное отличие от предыдущего сценария заключается в том, что в качестве ответного сообщения возвращается сообщение об ошибке SOAP. Если `propagateActivity` = `true` значение равно, идентификатор действия сообщения запроса добавляется в сообщение об ошибке SOAP.  
  
## <a name="synchronous-one-way-without-errors"></a>Синхронная односторонняя связь без ошибок  
 Единственное отличие от первого сценария заключается в том, что на сервер не возвращается сообщение. Для протоколов, основанных на HTTP, на клиент все же возвращается состояние (допустимое или ошибка). Это связано с тем, что HTTP — единственный протокол с семантикой запросов и ответов, которая является частью стека протокола WCF. Поскольку обработка TCP скрыта от WCF, клиенту не отправляется подтверждение.  
  
## <a name="synchronous-one-way-with-errors"></a>Синхронная односторонняя связь с ошибками  
 Если произошла ошибка при обработке сообщения (Q или далее), клиенту не возвращается уведомление. Эта логика идентична сценарию «Синхронная односторонняя связь без ошибок». Если требуется получить сообщение об ошибке, использовать сценарий с односторонней связью не рекомендуется.  
  
## <a name="duplex"></a>Дуплекс  
 Отличие от предыдущих сценариев заключается в том, что клиент выполняет роль службы, создавая действия ReceiveBytes и ProcessMessage, подобно сценариям для асинхронной связи.
