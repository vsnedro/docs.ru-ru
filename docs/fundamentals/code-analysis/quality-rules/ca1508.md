---
title: 'CA1508: Избегайте неработающего условного кода (анализ кода)'
description: 'Дополнительные сведения о правиле анализа кода CA1508: предотвращение неработающего условного кода'
ms.date: 04/23/2020
ms.topic: reference
f1_keywords:
- CA1508
- AvoidDeadConditionalCode
helpviewer_keywords:
- CA1508
- AvoidDeadConditionalCode
author: mavasani
ms.author: mavasani
ms.openlocfilehash: 7588173ad3162b799d3189ce5724db941d0784f0
ms.sourcegitcommit: e301979e3049ce412d19b094c60ed95b316a8f8c
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/16/2020
ms.locfileid: "97594999"
---
# <a name="ca1508-avoid-dead-conditional-code"></a>CA1508: Избегайте появления неиспользуемого условного кода

| | Значение |
|-|-|
| **Идентификатор правила** |CA1508|
| **Категория** |Поддержка Microsoft.|
| **Исправление не критическое или не критическое** |Не критическое|

## <a name="cause"></a>Причина

Метод имеет условный код, который всегда вычисляется как `true` или `false` во время выполнения. Это приводит к неработающему коду в `false` ветви условия.

По умолчанию это правило анализирует всю базу кода, но это можно [настроить](#configure-code-to-analyze).

## <a name="rule-description"></a>Описание правила

Методы могут иметь условный код, например операторы If, двоичные выражения ( `==` , `!=` , `<` , `>` ), проверки значений NULL и т. д. Например, рассмотрим следующий код:

```csharp
public void M(int i, int j)
{
    if (i != 0)
    {
        return;
    }

    if (j != 0)
    {
        return;
    }

    // Below condition will always evaluate to 'false' as 'i' and 'j' are both '0' here.
    if (i != j)
    {
        // Code in this 'if' branch is dead code.
        // It can either be removed or refactored.
        ...
    }
}
```

Компиляторы C# и VB выполняют анализ условных проверок с использованием _значений констант_ времени компиляции, которые всегда имеют значение `true` или `false` . Этот анализатор выполняет анализ потока данных переменных, не являющихся константами, чтобы определить избыточные условные проверки, включающие _неконстантные значения_. В приведенном выше коде анализатор определяет, что `i` и `j` оба являются `0` для всех ветвей кода, доступных для `i != j` проверки. Таким образом, эта проверка всегда будет оцениваться `false` во время выполнения. Код в операторе If является неиспользуемым кодом и может быть удален или подвергнут рефакторингу. Аналогичным образом анализатор отслеживает значения NULL переменных и сообщает о избыточных проверках значений NULL.

> [!NOTE]
> Этот анализатор выполняет ресурсоемкий анализ потоков данных, не являющихся константными значениями. Это может увеличить общее время компиляции для определенных баз кода.

## <a name="when-to-suppress-warnings"></a>Когда следует подавлять предупреждения

Нарушение этого правила можно отключить, если вы не беспокоитесь об обслуживании кода. Также можно подавить нарушения, идентифицированные как ложные срабатывания. Это возможно при наличии параллельного кода, который может выполняться из нескольких потоков.

## <a name="configure-code-to-analyze"></a>Настройка анализируемого кода

Используйте следующие параметры, чтобы настроить, на какие части базы кода следует запускать это правило.

- [Исключить конкретные символы](#exclude-specific-symbols)
- [Исключить определенные типы и их производные типы](#exclude-specific-types-and-their-derived-types)

Эти параметры можно настроить только для этого правила, для всех правил или для всех правил в этой категории (обслуживание). Дополнительные сведения см. в разделе [Параметры конфигурации правила качества кода](../code-quality-rule-options.md).

[!INCLUDE[excluded-symbol-names](~/includes/code-analysis/excluded-symbol-names.md)]

[!INCLUDE[excluded-type-names-with-derived-types](~/includes/code-analysis/excluded-type-names-with-derived-types.md)]

## <a name="see-also"></a>См. также раздел

- [Правила удобства поддержки](maintainability-warnings.md)
