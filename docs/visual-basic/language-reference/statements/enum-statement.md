---
title: Оператор Enum
ms.date: 07/20/2015
f1_keywords:
- vb.Enum
helpviewer_keywords:
- enumerated constants [Visual Basic]
- Enum statement [Visual Basic]
- Private keyword [Visual Basic], Enum statements
- Public keyword [Visual Basic], in Enum statement
- variables [Visual Basic], enumeration
- constants [Visual Basic], enumerated
ms.assetid: a45e51f1-65ff-48e1-bf32-79130f137377
ms.openlocfilehash: 976cc68d67c69ec86918962ab2dd3406d15aed9a
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2020
ms.locfileid: "84404736"
---
# <a name="enum-statement-visual-basic"></a>Оператор Enum (Visual Basic)

Объявляет перечисление и определяет значения его элементов.

## <a name="syntax"></a>Синтаксис

```vb
[ <attributelist> ] [ accessmodifier ]  [ Shadows ]
Enum enumerationname [ As datatype ]
   memberlist
End Enum
```

## <a name="parts"></a>Компоненты

- `attributelist`

  Необязательный элемент. Список атрибутов, которые применяются к этому перечислению. [Список атрибутов](attribute-list.md) необходимо заключить в угловые скобки (" `<` " и " `>` ").

  <xref:System.FlagsAttribute>Атрибут указывает, что значение экземпляра перечисления может включать несколько членов перечисления и что каждый элемент представляет битовое поле в значении перечисления.

- `accessmodifier`

  Необязательный элемент. Указывает, какой код может получить доступ к этому перечислению. Может принимать следующие значения:

  - [Открытый](../modifiers/public.md)

  - [От](../modifiers/protected.md)

  - [Объявление](../modifiers/friend.md)

  - [Частное](../modifiers/private.md)

  - [Protected Friend](../modifiers/protected-friend.md)

  - [Частный защищенный](../modifiers/private-protected.md)

- `Shadows`

  Необязательный элемент. Указывает, что это перечисление повторно объявляет и скрывает идентично именованный элемент программирования или набор перегруженных элементов в базовом классе. [Тени](../modifiers/shadows.md) можно указывать только в самом перечислении, а не на любом из его членов.

- `enumerationname`

  Обязательный. Имя перечисления. Сведения о допустимых именах см. в разделе [Имена объявленных элементов](../../programming-guide/language-features/declared-elements/declared-element-names.md).

- `datatype`

  Необязательный элемент. Тип данных перечисления и всех его элементов.

- `memberlist`

  Обязательный. Список констант членов, объявляемых в этой инструкции. В отдельных строках исходного кода отображаются несколько элементов.

  Каждый `member` из них имеет следующий синтаксис и фрагменты:`[<attribute list>] member name [ = initializer ]`

  |Часть|Описание|
  |---|---|
  |`membername`|Обязательный. Имя этого элемента.|
  |`initializer`|Необязательный элемент. Выражение, которое вычисляется во время компиляции и присваивается этому элементу.|

- `End` `Enum`

  Завершает блок `Enum`.

## <a name="remarks"></a>Комментарии

Если имеется набор неизменяемых значений, логически связанных друг с другом, их можно определить вместе в перечислении. Это дает осмысленные имена для перечисления и его членов, которые проще запомнить, чем их значения. Затем можно использовать элементы перечисления во многих местах кода.

Ниже перечислены преимущества использования перечислений.

- Сокращает количество ошибок, вызванных перечислением или неотрицательным вводом чисел.

- Упрощает изменение значений в будущем.

- Упрощает чтение кода, что означает меньшее количество ошибок, которые могут возникать.

- Обеспечивает прямую совместимость. При использовании перечислений код менее вероятен, если в будущем кто-то изменит значения, соответствующие именам элементов.

Перечисление имеет имя, базовый тип данных и набор элементов. Каждый элемент представляет константу.

Перечисление, объявленное на уровне класса, структуры, модуля или интерфейса, за пределами любой процедуры, является *перечислителем элементов*. Он является членом класса, структуры, модуля или интерфейса, объявляющего его.

К перечислениям членов можно обращаться из любого места в своем классе, структуре, модуле или интерфейсе. Код за пределами класса, структуры или модуля должен уточнять имя перечисления членов именем этого класса, структуры или модуля. Можно избежать необходимости использовать полные имена, добавив оператор [Imports](imports-statement-net-namespace-and-type.md) в исходный файл.

Перечисление, объявленное на уровне пространства имен вне любого класса, структуры, модуля или интерфейса, является членом пространства имен, в котором оно отображается.

*Контекст объявления* для перечисления должен быть исходным файлом, пространством имен, классом, структурой, модулем или интерфейсом и не может быть процедурой. Дополнительные сведения см. в разделе [Контексты объявления и уровни доступа по умолчанию](declaration-contexts-and-default-access-levels.md).

К перечислению можно применять атрибуты в целом, но не в отдельные элементы. Атрибут вносит сведения в метаданные сборки.

## <a name="data-type"></a>Тип данных

`Enum`Оператор может объявлять тип данных перечисления. Каждый член принимает тип данных перечисления. Можно указать `Byte` , `Integer` , `Long` , `SByte` , `Short` , `UInteger` , `ULong` или `UShort` .

Если не указать `datatype` для перечисления, каждый элемент принимает тип данных его `initializer` . Если заданы оба параметра `datatype` и `initializer` , тип данных `initializer` должен быть преобразован в `datatype` . Если оба `datatype` `initializer` параметра и не указаны, по умолчанию используется тип данных `Integer` .

## <a name="initializing-members"></a>Инициализация членов

`Enum`Оператор может инициализировать содержимое выбранных элементов в `memberlist` . Используется `initializer` для предоставления выражения, присваиваемого элементу.

Если вы не укажете `initializer` для члена, Visual Basic инициализирует его как ноль (если он является первым `member` в `memberlist` ) или значение, большее значения, превышающего, чем ранее `member` .

Выражение, передаваемое в each, `initializer` может быть любым сочетанием литералов, других уже определенных констант и уже определенных членов перечисления, включая предыдущий элемент этого перечисления. Для объединения таких элементов можно использовать арифметические и логические операторы.

В нельзя использовать переменные или функции `initializer` . Однако можно использовать ключевые слова преобразования, такие как `CByte` и `CShort` . Можно также использовать `AscW` , если вы вызываете его с константой `String` или `Char` аргументом, так как это может быть вычислено во время компиляции.

Перечисления не могут иметь значения с плавающей запятой. Если члену присваивается значение с плавающей запятой и `Option Strict` для него задано состояние ON, возникает ошибка компилятора. Если параметр `Option Strict` равен OFF, значение автоматически преобразуется в `Enum` тип.

Если значение элемента превышает допустимый диапазон для базового типа данных или если любой элемент инициализируется максимальным значением, разрешенным базовым типом данных, то компилятор сообщает об ошибке.

## <a name="modifiers"></a>Модификаторы

Перечисления членов класса, структуры, модуля и интерфейса по умолчанию имеют открытый доступ. Уровни доступа можно изменить с помощью модификаторов доступа. Перечисления членов пространств имен по умолчанию имеют дружественный доступ. Уровни доступа можно изменить на "общий", но не на "частный" или "защищенный". Дополнительные сведения см. [в разделе уровни доступа в Visual Basic](../../programming-guide/language-features/declared-elements/access-levels.md).

Все члены перечисления имеют общий доступ, и в них нельзя использовать никакие модификаторы доступа. Однако если перечисление имеет более ограниченный уровень доступа, приоритет имеет указанный уровень доступа к перечислению.

По умолчанию все перечисления являются типами, а их поля — константами. Поэтому `Shared` `Static` Ключевые слова, и `ReadOnly` не могут быть использованы при объявлении перечисления или его членов.

## <a name="assigning-multiple-values"></a>Присваивание нескольких значений

Перечисления обычно представляют взаимоисключающие значения. Включив <xref:System.FlagsAttribute> атрибут в `Enum` объявление, можно присвоить экземпляру перечисления несколько значений. <xref:System.FlagsAttribute>Атрибут указывает, что перечисление будет рассматриваться как битовое поле, то есть набор флагов. Они называются *побитовыми* перечислениями.

Если перечисление объявляется с помощью <xref:System.FlagsAttribute> атрибута, для значений рекомендуется использовать степени 2, то есть 1, 2, 4, 8, 16 и т. д. Также рекомендуется, чтобы "None" было именем члена, значение которого равно 0. Дополнительные рекомендации см. в статьях <xref:System.FlagsAttribute> и <xref:System.Enum> .

## <a name="example"></a>Пример

В следующем примере показано использование оператора `Enum`. Обратите внимание, что элемент называется `EggSizeEnum.Medium` , а не как `Medium` .

[!code-vb[VbEnumsTask#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbEnumsTask/VB/Class1.vb#41)]

## <a name="example"></a>Пример

Метод в следующем примере находится за пределами `Egg` класса. Таким образом, `EggSizeEnum` имеет полное имя `Egg.EggSizeEnum` .

[!code-vb[VbEnumsTask#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbEnumsTask/VB/Class1.vb#42)]

## <a name="example"></a>Пример

В следующем примере оператор используется `Enum` для определения связанного набора именованных постоянных значений. В этом случае значения представляют собой цвета, которые можно выбрать для создания форм ввода данных для базы данных.

[!code-vb[VbEnumsTask#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbEnumsTask/VB/Class2.vb#30)]

## <a name="example"></a>Пример

В следующем примере показаны значения, включающие положительные и отрицательные числа.

[!code-vb[VbEnumsTask#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbEnumsTask/VB/Class2.vb#31)]

## <a name="example"></a>Пример

В следующем примере `As` используется предложение для указания `datatype` перечисления.

[!code-vb[VbEnumsTask#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbEnumsTask/VB/Class2.vb#6)]

## <a name="example"></a>Пример

В следующем примере показано, как использовать побитовое перечисление. Экземпляру побитового перечисления можно назначить несколько значений. `Enum`Объявление включает <xref:System.FlagsAttribute> атрибут, указывающий, что перечисление может рассматриваться как набор флагов.

[!code-vb[VbEnumsTask#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbEnumsTask/VB/Class1.vb#61)]

## <a name="example"></a>Пример

В следующем примере выполняется итерация по перечислению. Он использует <xref:System.Enum.GetNames%2A> метод для получения массива имен членов из перечисления и <xref:System.Enum.GetValues%2A> для получения массива значений элементов.

[!code-vb[VbEnumsTask#51](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbEnumsTask/VB/Class1.vb#51)]

## <a name="see-also"></a>См. также раздел

- <xref:System.Enum>
- <xref:Microsoft.VisualBasic.Strings.AscW%2A>
- [Оператор Const](const-statement.md)
- [Оператор Dim](dim-statement.md)
- [Явные и неявные преобразования](../../programming-guide/language-features/data-types/implicit-and-explicit-conversions.md)
- [Type Conversion Functions](../functions/type-conversion-functions.md)
- [Константы и перечисления](../constants-and-enumerations.md)
