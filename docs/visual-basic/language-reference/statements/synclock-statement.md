---
title: Оператор SyncLock
ms.date: 07/20/2015
f1_keywords:
- vb.SyncLock
- SyncLock
helpviewer_keywords:
- threading [Visual Basic], locks
- SyncLock statement [Visual Basic]
- locks, threads
ms.assetid: 14501703-298f-4d43-b139-c4b6366af176
ms.openlocfilehash: cc8706b95e0785459e36abe27ce915b5bab8711a
ms.sourcegitcommit: d2db216e46323f73b32ae312c9e4135258e5d68e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/22/2020
ms.locfileid: "90875201"
---
# <a name="synclock-statement"></a>Оператор SyncLock

Получает монопольную блокировку для блока операторов перед выполнением блока.  
  
## <a name="syntax"></a>Синтаксис  
  
```vb  
SyncLock lockobject  
    [ block ]  
End SyncLock  
```  
  
## <a name="parts"></a>Компоненты  

 `lockobject`  
 Обязательный элемент. Выражение, результатом которого является ссылка на объект.  
  
 `block`  
 Необязательный элемент. Блок инструкций, которые выполняются при получении блокировки.  
  
 `End SyncLock`  
 Завершает `SyncLock` блок.  
  
## <a name="remarks"></a>Remarks  

 `SyncLock`Инструкция гарантирует, что несколько потоков не выполняют блок инструкций одновременно. `SyncLock` предотвращает вход каждого потока в блок до тех пор, пока не будет выполнен другой поток.  
  
 Чаще всего используется `SyncLock` для защиты данных от одновременного обновления более чем одним потоком. Если инструкции, управляющие данными, должны переходить к завершению без прерывания, помещайте их внутрь `SyncLock` блока.  
  
 Блок операторов, защищенный монопольной блокировкой, иногда называют *критическим разделом*.  
  
## <a name="rules"></a>Правила  
  
- Ветвления. Нельзя выполнить ветвление в `SyncLock` блок, находящийся за пределами блока.  
  
- Блокировка значения объекта. Значение `lockobject` не может быть `Nothing` . Объект Lock необходимо создать до его использования в `SyncLock` инструкции.  
  
     Нельзя изменить значение `lockobject` во время выполнения `SyncLock` блока. Механизм требует, чтобы объект блокировки оставался без изменений.  
  
- Нельзя использовать оператор [await](../operators/await-operator.md) в `SyncLock` блоке.  
  
## <a name="behavior"></a>Поведение  
  
- Механизм. Когда поток достигает `SyncLock` инструкции, он вычисляет `lockobject` выражение и приостанавливает выполнение до тех пор, пока не получит монопольную блокировку на объект, возвращенный выражением. Когда другой поток достигает `SyncLock` оператора, он не получает блокировку до тех пор, пока первый поток не выполнит `End SyncLock` инструкцию.  
  
- Защищенные данные. Если `lockobject` является `Shared` переменной, монопольная блокировка запрещает потоку в любом экземпляре класса выполнять `SyncLock` блок, пока он выполняется любым другим потоком. Это защищает данные, которые являются общими для всех экземпляров.  
  
     Если `lockobject` является переменной экземпляра (не `Shared` ), блокировка предотвращает выполнение блока в текущем экземпляре в `SyncLock` то же время, что и другой поток в том же экземпляре. Это защищает данные, обслуживаемые отдельным экземпляром.  
  
- Приобретение и выпуск. `SyncLock`Блок ведет себя как `Try...Finally` конструкция, в которой `Try` блок получает монопольную блокировку `lockobject` , а `Finally` блок освобождает его. По этой причине `SyncLock` блок гарантирует освобождение блокировки, независимо от того, как вы выйдете из блока. Это справедливо даже в случае необработанного исключения.  
  
- Платформа вызывает. `SyncLock`Блок получает и освобождает монопольную блокировку, вызывая `Enter` `Exit` методы и `Monitor` класса в <xref:System.Threading> пространстве имен.  
  
## <a name="programming-practices"></a>Рекомендации по программированию  

 `lockobject`Выражение всегда должно быть результатом вычисления объекта, который относится исключительно к вашему классу. Следует объявить `Private` переменную объекта для защиты данных, принадлежащих текущему экземпляру, или `Private Shared` объектную переменную для защиты данных, общих для всех экземпляров.  
  
 Не следует использовать `Me` ключевое слово для предоставления объекта блокировки для данных экземпляра. Если код, внешний для класса, имеет ссылку на экземпляр класса, он может использовать эту ссылку как объект блокировки, который `SyncLock` совершенно отличается от вашего блока, защищая различные данные. Таким образом, класс и другой класс могут блокировать вызов друг друга из несвязанных `SyncLock` блоков. Подобная блокировка строки может быть проблематичной, так как любой другой код в процессе, использующий одну и ту же строку, будет совместно использовать одну и ту же блокировку.  
  
 Не следует также использовать `Me.GetType` метод для предоставления объекта блокировки для общих данных. Это происходит потому, что `GetType` всегда возвращает один и тот же `Type` объект для заданного имени класса. Внешний код может вызвать `GetType` в классе и получить тот же объект блокировки, который вы используете. Это приведет к тому, что два класса блокируют друг друга из `SyncLock` блоков.  
  
## <a name="examples"></a>Примеры  
  
### <a name="description"></a>Описание  

 В следующем примере показан класс, который поддерживает простой список сообщений. Он хранит сообщения в массиве и последнем используемом элементе этого массива в переменной. `addAnotherMessage`Процедура увеличивает последний элемент и сохраняет новое сообщение. Эти две операции защищаются `SyncLock` `End SyncLock` инструкциями и, так как после увеличения последнего элемента новое сообщение должно быть сохранено до того, как любой другой поток снова сможет снова увеличить последний элемент.  
  
 Если `simpleMessageList` класс поделился одним списком сообщений между всеми его экземплярами, переменные `messagesList` и будут `messagesLast` объявлены как `Shared` . В этом случае переменная `messagesLock` также должна иметь значение `Shared` , чтобы в каждом экземпляре использовался один объект блокировки.  
  
### <a name="code"></a>Код  

 [!code-vb[VbVbalrThreading#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrThreading/VB/Class1.vb#1)]  
  
### <a name="description"></a>Описание  

 В следующем примере используются потоки и `SyncLock` . При условии `SyncLock` , что оператор представлен, блок инструкций является критической секцией и `balance` никогда не становится отрицательным числом. Можно закомментировать `SyncLock` операторы и, `End SyncLock` чтобы увидеть результат выхода из `SyncLock` ключевого слова.  
  
### <a name="code"></a>Код  

 [!code-vb[VbVbalrThreading#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrThreading/VB/class2.vb#21)]  
  
### <a name="comments"></a>Комментарии  
  
## <a name="see-also"></a>См. также

- <xref:System.Threading.Monitor?displayProperty=nameWithType>
- <xref:System.Threading.Interlocked?displayProperty=nameWithType>
- [Обзор примитивов синхронизации](../../../standard/threading/overview-of-synchronization-primitives.md)
