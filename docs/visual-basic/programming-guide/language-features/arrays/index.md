---
title: Массивы
ms.date: 12/06/2017
f1_keywords:
- vb.Array
helpviewer_keywords:
- arrays [Visual Basic]
- Visual Basic, arrays
ms.assetid: dbf29737-b589-4443-bee6-a27588d9c67e
ms.openlocfilehash: 5093f28f05c5b72294dce9a4e69723acafb31a9f
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2020
ms.locfileid: "84413095"
---
# <a name="arrays-in-visual-basic"></a>Массивы в Visual Basic

Массив — это набор значений, которые являются терминами *элементы*, логически взаимосвязаны друг с другом. Например, массив может состоять из числа учащихся в словаре грамматики. Каждый элемент массива — это количество учащихся одного уровня. Аналогичным образом массив может состоять из оценок учащегося для класса. Каждый элемент массива является однозначным.

Можно хранить отдельные переменные для хранения каждого из наших элементов данных. Например, если наше приложение анализирует оценки учащихся, можно использовать отдельную переменную для каждой категории учащегося, например `englishGrade1` , и `englishGrade2` т. д. Этот подход имеет три основных ограничения:

- Во время разработки мы должны знать, сколько оценок нужно обменять.
- Обработка большого количества оценок быстро оказывается неудобной. Это, в свою очередь, значительно повышает вероятность возникновения серьезных ошибок в приложении.
- Его сложно поддерживать. Для каждого нового добавляемого класса необходимо, чтобы приложение было изменено, перекомпилировано и развернуто.

Используя массив, можно ссылаться на эти связанные значения по одному и тому же имени и использовать число, которое называется *индексом* или *подиндексом* для обозначения отдельного элемента в зависимости от его позиции в массиве. Индексы в диапазоне от 0 до 1 меньше, чем общее число элементов в массиве. При использовании синтаксиса Visual Basic для определения размера массива указывается его самый высокий индекс, а не общее число элементов в массиве. Можно работать с массивом как с единицей, а возможность итерации элементов освобождает вас от необходимости знать, сколько элементов оно содержит во время разработки.

Несколько простых примеров перед подробным описанием:

```vb
' Declare a single-dimension array of 5 numbers.
Dim numbers(4) As Integer

' Declare a single-dimension array and set its 4 values.
Dim numbers = New Integer() {1, 2, 4, 8}

' Change the size of an existing array to 16 elements and retain the current values.
ReDim Preserve numbers(15)

' Redefine the size of an existing array and reset the values.
ReDim numbers(15)

' Declare a 6 x 6 multidimensional array.
Dim matrix(5, 5) As Double

' Declare a 4 x 3 multidimensional array and set array element values.
Dim matrix = New Integer(3, 2) {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}}

' Declare a jagged array
Dim sales()() As Double = New Double(11)() {}
```

## <a name="array-elements-in-a-simple-array"></a>Элементы массива в простом массиве

Давайте создадим массив с именем `students` для хранения числа учащихся в каждом классе в школе. Индексы элементов находятся в диапазоне от 0 до 6. Использование этого массива проще, чем объявление семи переменных.

На следующем рисунке показан `students` массив. Для каждого элемента массива:

- индекс элемента представляет школьный класс (индекс 0 представляет детский сад);

- значение, содержащееся в элементе, представляет число учеников в этом классе.

![Схема, показывающая массив чисел учащихся](./media/index/students-array-elements.gif)

В следующем примере содержится код Visual Basic, который создает и использует массив:

[!code-vb[simple-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/simple-array.vb)]

В этом примере выполняется три вещи:

- Он объявляет `students` массив с семью элементами. Число `6` в объявлении массива указывает последний индекс в массиве; он меньше, чем число элементов в массиве.
- Он присваивает значения каждому элементу в массиве. Доступ к элементам массива осуществляется с помощью имени массива, включая индекс отдельного элемента в круглых скобках.
- В нем перечисляются все значения массива. В примере используется [`For`](../../../language-reference/statements/for-next-statement.md) оператор для доступа к каждому элементу массива по номеру индекса.

`students`Массив в предыдущем примере является одномерным массивом, так как он использует один индекс. Массив, использующий более одного индекса или подстрочного, называется *многомерным*. Дополнительные сведения см. в остальной части этой статьи и [в разделе измерения массива в Visual Basic](array-dimensions.md).

## <a name="creating-an-array"></a>Создание массива

Размер массива можно определить несколькими способами.

- Размер можно указать при объявлении массива:

  [!code-vb[creating1](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#1)]

- Можно использовать предложение, `New` чтобы указать размер массива при его создании:

  [!code-vb[creating2](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#2)]

При наличии существующего массива его размер можно переопределить с помощью [`ReDim`](../../../language-reference/statements/redim-statement.md) инструкции. Можно указать, что `ReDim` инструкция сохранит значения в массиве, или можно указать, что он создает пустой массив. В приведенном ниже примере показаны различные варианты использования оператора `ReDim` для изменения размера существующего массива.

[!code-vb[redimensioning](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#3)]

Дополнительные сведения см. в описании [оператора ReDim](../../../language-reference/statements/redim-statement.md).

## <a name="storing-values-in-an-array"></a>Сохранение значений в массиве

К любой позиции в массиве можно получить доступ, используя индекс типа `Integer`. Вы можете сохранять и извлекать значения массива, ссылаясь на позицию в нем с помощью индекса, заключенного в скобки. Индексы для многомерных массивов разделяются запятыми (,). Для каждого измерения массива требуется один индекс.

В следующем примере показаны некоторые инструкции, которые хранят и извлекают значения в массивах.

[!code-vb[store-and-retrieve](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/store-and-retrieve.vb)]

## <a name="populating-an-array-with-array-literals"></a>Заполнение массива литералами массива

С помощью литерала массива можно заполнить массив начальным набором значений во время его создания. Литерал массива состоит из списка разделенных запятыми значений, заключенных в фигурные скобки (`{}`).

При создании массива с помощью литерала массива можно либо указать тип массива, либо использовать определение типа для задания типа массива. В следующем примере показаны оба варианта.

[!code-vb[create-with-literals](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#4)]

При использовании вывода типа тип массива определяется *главным типом* в списке литеральных значений. Главным типом является тип, к которому могут расширяться все другие типы в массиве. Если такой уникальный тип нельзя определить, то главным будет тип, до которого можно сузить все другие типы массива. Если ни один из указанных уникальных типов нельзя определить, главным типом будет `Object`. Например, если список значений для литерала массива содержит значения типов `Integer`, `Long`и `Double`, результирующий массив будет иметь тип `Double`. Поскольку `Integer` и `Long` расширяются только до `Double` , `Double` является главным типом. Для получения дополнительной информации см. [Widening and Narrowing Conversions](../data-types/widening-and-narrowing-conversions.md).

> [!NOTE]
> Вывод типа можно использовать только для массивов, определенных как локальные переменные в члене типа. Если явное определение типа отсутствует, массивы, определенные с литералами массива на уровне класса, имеют тип `Object[]` . Дополнительные сведения см. в разделе [определение локального типа](../variables/local-type-inference.md).

Обратите внимание, что в предыдущем примере определяется `values` как массив типа, `Double` хотя все литералы массива имеют тип `Integer` . Этот массив можно создать, так как значения в литерале массива могут расширяться до `Double` значений.

Можно также создать и заполнить многомерный массив с помощью *вложенных литералов массива*. Вложенные литералы массива должны иметь ряд измерений, которые соответствуют результирующему массиву. В следующем примере создается двухмерный массив целых чисел с помощью вложенных литералов массива.

[!code-vb[nested-array-literals](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#5)]

При использовании вложенных литералов массива для создания и заполнения массива возникает ошибка, если число элементов в литералах вложенных массивов не совпадает. Ошибка также возникает, если вы явно объявили переменную массива так, чтобы число измерений не превышало литералы массива.

Точно так же, как и для одномерные массивов, при создании многомерного массива с вложенными литералами массива можно полагаться на определение типа. Выводимый тип является главным типом для всех значений во всех литералах массива для всех уровней вложенности. В следующем примере создается двухмерный массив типа `Double[,]` из значений типа `Integer` и `Double` .

[!code-vb[nested-type-inference](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/create-array.vb#6)]

Дополнительные примеры можно найти в статье [How to: Initialize an Array Variable in Visual Basic](how-to-initialize-an-array-variable.md) (Практическое руководство. Инициализация переменной массива в Visual Basic).

## <a name="iterating-through-an-array"></a>Проход по массиву

При итерации по массиву вы обращаетесь к каждому элементу в массиве от самого низкого индекса к верхнему или от самого низкого. Как правило, используйте [для... Next](../../../language-reference/statements/for-next-statement.md) или [For Each... Оператор Next](../../../language-reference/statements/for-each-next-statement.md) для итерации элементов массива. Если вы не знакомы с верхними границами массива, можно вызвать <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> метод, чтобы получить наибольшее значение индекса. Хотя наименьшее значение индекса почти всегда равно 0, можно вызвать <xref:System.Array.GetLowerBound%2A?displayProperty=nameWithType> метод, чтобы получить наименьшее значение индекса.

В следующем примере выполняется итерация по одномерным массиву с помощью [`For...Next`](../../../language-reference/statements/for-next-statement.md) инструкции.

[!code-vb[iterate-one-dimensional-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate1d.vb)]

В следующем примере выполняется перебор многомерного массива с помощью [`For...Next`](../../../language-reference/statements/for-next-statement.md) инструкции. Метод <xref:System.Array.GetUpperBound%2A> имеет параметр, который определяет измерение. `GetUpperBound(0)`Возвращает самый верхний индекс первого измерения и `GetUpperBound(1)` возвращает наибольший индекс второго измерения.

[!code-vb[iterate-two-dimensional-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate2d.vb)]

В следующем примере используется объект [For Each... Оператор Next](../../../language-reference/statements/for-each-next-statement.md)для итерации одномерного массива и двумерного массива.

[!code-vb[iterate-for-each-next](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/iterate-for-each-next.vb)]

## <a name="array-size"></a>Размер массива

Размер массива является произведением длин всех его измерений. Он представляет собой общее число элементов, в данный момент содержащихся в массиве.  Например, в следующем примере объявляется двухмерный массив с четырьмя элементами в каждом измерении. Как видно из выходных данных в примере, размер массива равен 16 (или (3 + 1) * (3 + 1).

[!code-vb[array-size](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/array-size.vb)]

> [!NOTE]
> Это обсуждение размера массива не применяется к массивам зубчатых размеров. Сведения о массивах немассивности и определении размера массива массивов см [. в разделе массива массивов](#jagged-arrays) .

Размер массива можно определить с помощью свойства <xref:System.Array.Length%2A?displayProperty=nameWithType>. Длину каждого измерения многомерного массива можно узнать с помощью <xref:System.Array.GetLength%2A?displayProperty=nameWithType> метода.

Можно изменить размер переменной массива, назначив ей новый объект массива или используя инструкцию [ `ReDim` инструкции](../../../language-reference/statements/redim-statement.md) . В следующем примере оператор используется `ReDim` для изменения массива 100-element на массив 51-element.

[!code-vb[resize-an-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/array-size2.vb)]

Существует ряд особенностей, о которых следует помнить при работе с размером массива.

|||
|---|---|
|Длина измерения|Индекс каждого измерения основан на 0, что означает, что он находится в диапазоне от 0 до верхней границы. Таким образом, длина данного измерения больше, чем объявленная верхняя граница этого измерения.|
|Ограничения длины|Длина каждого измерения массива ограничена максимальным значением `Integer` типа данных, которое равно <xref:System.Int32.MaxValue?displayProperty=nameWithType> или (2 ^ 31)-1. Однако общий размер массива также ограничен доступной памятью в системе. При попытке инициализировать массив, размер которого превышает объем доступной памяти, среда выполнения создает исключение <xref:System.OutOfMemoryException> .|
|Размер и размер элемента|Размер массива не зависит от типа его элементов. Размер всегда представляет общее число элементов, а не число байтов, используемых в памяти.|
|Затраты памяти|Небезопасно делать какие-либо предположения относительно способа хранения массива в памяти. Хранение зависит от разрядности платформы, поэтому один и тот же массив может занимать больше памяти в 64-разрядных системах, чем в 32-разрядных. В зависимости от конфигурации системы при инициализации массива среда CLR может использовать такие способы хранения, как упаковка элементов максимально близко друг к другу или выравнивание всех элементов по естественным аппаратным границам памяти. Кроме того, массив нуждается в хранении служебной информации, и размер этой информации возрастает при добавлении каждого измерения.|

## <a name="the-array-type"></a>Тип массива

Каждый массив имеет тип данных, который отличается от типа данных его элементов. Не существует единого типа данных, подходящего для всех массивов. Вместо этого тип данных массива определяется числом измерений ( *рангом*) массива и типом данных его элементов. Две переменные массива имеют один и тот же тип данных, только если они имеют одинаковый ранг и их элементы имеют один и тот же тип данных. Длины измерений массива не влияют на тип данных массива.

Каждый массив наследуется от класса <xref:System.Array?displayProperty=nameWithType>, и вы можете объявить переменную типа `Array`, но не можете создать массив типа `Array`. Например, несмотря на то, что следующий код объявляет `arr` переменную как тип `Array` и вызывает <xref:System.Array.CreateInstance%2A?displayProperty=nameWithType> метод для создания экземпляра массива, тип массива доказывается на Object [].

[!code-vb[array-class](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/array-class.vb)]

Кроме того, [оператор ReDim`Array` не может работать с переменной, объявленной с типом ](../../../language-reference/statements/redim-statement.md). По этим причинам, а для обеспечения безопасности типа рекомендуется объявлять каждый массив как конкретный тип.

Выяснить тип данных массива или его элементов можно несколькими способами.

- Можно вызвать <xref:System.Object.GetType%2A> метод для переменной, чтобы получить <xref:System.Type> объект, представляющий тип переменной во время выполнения. Объект <xref:System.Type> содержит подробные сведения в своих свойствах и методах.
- Можно передать переменную в функцию, <xref:Microsoft.VisualBasic.Information.TypeName%2A> чтобы получить `String` с именем типа времени выполнения.

В следующем примере `GetType` `TypeName` для определения типа массива вызывается метод и функция. Тип массива — `Byte(,)` . Обратите внимание, что <xref:System.Type.BaseType%2A?displayProperty=nameWithType> свойство также указывает, что базовый тип массива байтов является <xref:System.Array> классом.

[!code-vb[array-type](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/array-type.vb)]

## <a name="arrays-as-return-values-and-parameters"></a>Массивы как возвращаемые значения и параметры

Чтобы вернуть массив из процедуры `Function`, укажите тип данных массива и число измерений в качестве типа возвращаемого значения [оператора Function](../../../language-reference/statements/function-statement.md). Внутри функции объявите локальную переменную массива с тем же числом измерений и типом данных. В [оператор Return](../../../language-reference/statements/return-statement.md) включите локальную переменную массива без скобок.

Чтобы задать массив в качестве параметра процедуры `Sub` или `Function` , определите параметр как массив с указанными типом данных и количеством измерений. В вызове процедуры передайте переменную массива с тем же типом данных и количеством измерений.

В следующем примере `GetNumbers` функция возвращает `Integer()` одномерный массив типа `Integer` . Процедура `ShowNumbers` принимает аргумент `Integer()` .

[!code-vb[return-value-and-params](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/return-values-and-params.vb)]

В следующем примере `GetNumbersMultiDim` функция возвращает `Integer(,)` , двухмерный массив типа `Integer` .  Процедура `ShowNumbersMultiDim` принимает аргумент `Integer(,)` .

[!code-vb[multidimensional-return-value](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/return-values-and-params-2d.vb)]

## <a name="jagged-arrays"></a>Массивы массивов

Иногда структура данных в приложении является двухмерной, но не прямоугольной. Например, массив можно использовать для хранения данных о высокой температуре каждого дня месяца. Первое измерение массива представляет месяц, но второе измерение представляет количество дней, а число дней в месяце является неравномерным. Немассивный *массив*, который также называется *массивом массивов*, предназначен для таких сценариев. Немассивный массив — это массив, элементы которого также являются массивами. Массив массивов и каждый элемент в нем могут иметь одно или несколько измерений.

В следующем примере используется массив месяцев, каждый элемент которого является массивом дней. В примере используется массив массива, поскольку разные месяцы имеют разное количество дней.  В примере показано создание массива массивов, присвоение ему значений, а также извлечение и отображение его значений.

[!code-vb[jagged-arrays](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged.vb)]

В предыдущем примере значения массива массивов назначаются для элемента в отдельности с помощью `For...Next` цикла. Можно также присваивать значения элементам массива массивов с помощью вложенных литералов массива. Однако попытка использовать вложенные литералы массива (например, `Dim valuesjagged = {{1, 2}, {2, 3, 4}}` ) приводит к возникновению ошибки компилятора [BC30568](../../../misc/bc30568.md). Чтобы исправить ошибку, заключите внутренние литералы массива в круглые скобки. Круглые скобки принудительно оценивают выражение литерала массива, а результирующие значения используются с литералом внешнего массива, как показано в следующем примере.

[!code-vb[jagged-array-initialization](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged-assign.vb)]

Массив массива является одномерным массивом, элементы которого содержат массивы. Таким образом, <xref:System.Array.Length%2A?displayProperty=nameWithType> свойство и `Array.GetLength(0)` метод возвращают количество элементов в одномерном массиве и выдают исключение, `Array.GetLength(1)` <xref:System.IndexOutOfRangeException> так как массив массива не является многомерным. Число элементов в каждом подмассиве определяется путем извлечения значения свойства каждого подмассива <xref:System.Array.Length%2A?displayProperty=nameWithType> . В следующем примере показано, как определить количество элементов массива массивов.

[!code-vb[jagged-array-size](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/jagged-length.vb)]

## <a name="zero-length-arrays"></a>Массивы нулевой длины

Visual Basic отличает неинициализированный массив (массив, значение которого равно `Nothing` ) и *массив нулевой длины* или пустой массив (массив без элементов). Неинициализированный массив — это тот, который не был измерен или имел присвоенные ему значения. Пример:

```vb
Dim arr() As String
```

Массив нулевой длины объявляется с измерением-1. Пример:

```vb
Dim arrZ(-1) As String
```

Массив нулевой длины может потребоваться создать в указанных ниже случаях.

- Без риска возникновения <xref:System.NullReferenceException> исключения код должен обращаться к членам <xref:System.Array> класса, например <xref:System.Array.Length%2A> или <xref:System.Array.Rank%2A> , или вызвать функцию Visual Basic, например <xref:Microsoft.VisualBasic.Information.UBound%2A> .

- Вы хотите, чтобы ваш код был простым, не требуя проверки в `Nothing` качестве специального случая.

- Код взаимодействует с интерфейсом API, который требует передачи массива нулевой длины в одну или несколько процедур или возвращает массив нулевой длины из одной или нескольких процедур.

## <a name="splitting-an-array"></a>Разделение массива

В некоторых случаях может потребоваться разделить один массив на несколько массивов. Это включает определение точки или точек, в которых массив должен быть разделен, а затем спиттинг массив в два или более отдельных массива.

> [!NOTE]
> В этом разделе не рассматривается разделение одной строки на массив строк, основанный на каком-либо разделителе. Сведения о разбиении строки см. в описании <xref:System.String.Split%2A?displayProperty=nameWithType> метода.

Ниже приведены наиболее распространенные критерии разделения массива.

- Количество элементов в массиве. Например, может потребоваться разделить массив больше, чем заданное число элементов, на несколько приблизительно равных частей. Для этой цели можно использовать значение, возвращаемое <xref:System.Array.Length%2A?displayProperty=nameWithType> <xref:System.Array.GetLength%2A?displayProperty=nameWithType> методом или.

- Значение элемента, которое служит разделителем, указывающим место разделения массива. Можно выполнить поиск определенного значения, вызвав <xref:System.Array.FindIndex%2A?displayProperty=nameWithType> <xref:System.Array.FindLastIndex%2A?displayProperty=nameWithType> методы и.

После определения индекса или индексов, на которых массив должен быть разделен, можно создать отдельные массивы, вызвав <xref:System.Array.Copy%2A?displayProperty=nameWithType> метод.

В следующем примере массив разбивается на два массива приблизительно равного размера. (Если общее число элементов массива нечетное, первый массив содержит еще один элемент, чем второй.)

[!code-vb[splitting-an-array-by-length](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/split1.vb)]

В следующем примере массив строк разбивается на два массива на основе наличия элемента, значение которого равно "zzz", которое служит разделителем массива. Новые массивы не включают элемент, содержащий разделитель.

[!code-vb[splitting-an-array-by-delimiter](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/split2.vb)]

## <a name="joining-arrays"></a>Соединение массивов

Можно также объединить несколько массивов в один массив большего размера. Для этого также используется <xref:System.Array.Copy%2A?displayProperty=nameWithType> метод.

> [!NOTE]
> В этом разделе не обсуждается объединение массива строк в одну строку. Сведения о присоединении массива строк см. в описании <xref:System.String.Join%2A?displayProperty=nameWithType> метода.

Перед копированием элементов каждого массива в новый массив необходимо убедиться, что массив был инициализирован так, чтобы он был достаточно большим для размещения нового массива. Это можно сделать одним из двух способов.

- Используйте [`ReDim Preserve`](../../../language-reference/statements/redim-statement.md) инструкцию для динамического расширения массива перед добавлением в него новых элементов. Это самый простой способ, но это может привести к снижению производительности и чрезмерному потреблению памяти при копировании больших массивов.
- Вычислите общее число элементов, необходимых для нового большого массива, а затем добавьте в него элементы каждого исходного массива.

В следующем примере используется второй подход к добавлению четырех массивов с десятью элементами в один массив.

[!code-vb[joining-an-array](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/join.vb)]

Поскольку в этом случае исходные массивы невелики, можно также динамически расширять массив по мере добавления элементов каждого нового массива в него. Эту задачу решает следующий код.

[!code-vb[joining-an-array-dynamically](~/samples/snippets/visualbasic/programming-guide/language-features/arrays/join2.vb)]

## <a name="collections-as-an-alternative-to-arrays"></a>Коллекции в качестве альтернативы массивам

Массивы удобнее всего использовать для создания фиксированного числа строго типизированных объектов и работы с ними. Коллекции предоставляют более гибкий способ работы с группами объектов. В отличие от массивов, требующих явного изменения размера массива [ `ReDim` инструкцией](../../../language-reference/statements/redim-statement.md), коллекции растут и сжимаются динамически в соответствии с потребностями приложения.

При использовании `ReDim` для переизмерения массива Visual Basic создает новый массив и освобождает предыдущий. Это занимает время выполнения. Таким образом, если количество элементов, с которыми вы работаете, часто меняются, или вы не можете предсказать максимальное количество элементов, вы обычно получаете лучшую производительность, используя коллекцию.

Некоторые коллекции допускают назначение ключа любому объекту, который добавляется в коллекцию, чтобы в дальнейшем можно было быстро извлечь связанный с ключом объект из коллекции.

Если коллекция содержит элементы только одного типа данных, можно использовать один из классов в пространстве имен <xref:System.Collections.Generic?displayProperty=nameWithType>. Универсальная коллекция обеспечивает строгую типизацию, так что в нее нельзя добавить другие типы данных.

Более подробную информацию о коллекциях см. в статье [Коллекции](../../concepts/collections.md).

## <a name="related-topics"></a>Связанные темы

|Термин|Определение|
|----------|----------------|
|[Array Dimensions in Visual Basic](array-dimensions.md)|Объяснение ранга и измерений в массиве.|
|[How to: Initialize an Array Variable in Visual Basic](how-to-initialize-an-array-variable.md) (Практическое руководство. Инициализация переменной массива в Visual Basic)|Описывается заполнение массивов начальными значениями.|
|[How to: Sort An Array in Visual Basic](how-to-sort-an-array.md) (Практическое руководство. Сортировка массива в Visual Basic)|Показано, как сортировать элементы массива в алфавитном порядке.|
|[Практическое руководство. Присвоение одного массива другому](how-to-assign-one-array-to-another-array.md)|Описываются правила и действия для присвоения массива другой переменной массива.|
|[Устранение неполадок, связанных с массивами](troubleshooting-arrays.md)|Рассматриваются некоторые общие проблемы, возникающие при работе с массивами.|

## <a name="see-also"></a>См. также раздел

- <xref:System.Array?displayProperty=nameWithType>
- [Оператор Dim](../../../language-reference/statements/dim-statement.md)
- [Оператор reDim](../../../language-reference/statements/redim-statement.md)
