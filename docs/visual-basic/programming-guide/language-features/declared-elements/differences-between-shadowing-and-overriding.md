---
title: Различия между удаленным управлением и переопределением
ms.date: 07/20/2015
helpviewer_keywords:
- shadowing, vs. overriding
- overriding, vs. shadowing
ms.assetid: 2d014a0b-7630-407d-8f4e-24bd87987923
ms.openlocfilehash: a6ea83fadf18ef3be778e6de31c0eb4e65e74824
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2020
ms.locfileid: "84392874"
---
# <a name="differences-between-shadowing-and-overriding-visual-basic"></a>Различия между сокрытием и переопределением (Visual Basic)
При определении класса, который наследуется от базового класса, иногда требуется переопределить один или несколько элементов базового класса в производном классе. Для этой цели доступны как затенение, так и переопределение.  
  
## <a name="comparison"></a>Сравнение  
 Затенение и переопределение используются и при наследовании производного класса от базового класса, и при одновременном определении одного объявленного элемента с другим. Но существуют значительные различия между ними.  
  
 В следующей таблице сравнивается затенение с переопределением.  
  
||||  
|---|---|---|  
|Точка сравнения|Удаленное управление|Переопределение|  
|Цель|Обеспечивает защиту от последующего изменения базового класса, которое вводит член, уже определенный в производном классе|Достижение полиморфизма путем определения другой реализации процедуры или свойства с одной и той же вызывающей последовательностью<sup>1</sup>|  
|Переопределенный элемент|Любой объявленный тип элемента|Только процедура ( `Function` , `Sub` или `Operator` ) или свойство|  
|Переопределяющий элемент|Любой объявленный тип элемента|Только процедура или свойство с одинаковой вызывающей последовательностью<sup>1</sup>|  
|Уровень доступа переопределяющего элемента|Любой уровень доступа|Невозможно изменить уровень доступа переопределенного элемента|  
|Удобочитаемость и записи переопределения элемента|Любое сочетание|Невозможно изменить удобочитаемость или записи переопределенного свойства|  
|Управление переопределением|Элемент базового класса не может принудительно применять или запрещать тень|В элементе базового класса можно указать `MustOverride` , `NotOverridable` или`Overridable`|  
|Использование ключевого слова|`Shadows`рекомендуется в производном классе; `Shadows`предполагается, если не указаны ни значение `Shadows` `Overrides` <sup>2</sup>|`Overridable`или `MustOverride` требуется в базовом классе; `Overrides` требуется в производном классе|  
|Наследование переопределения элементов классами, производными от производного класса|Элемент с тенью, наследуемый более производными классами; затененный элемент по-прежнему скрыт<sup>3</sup>|Переопределяющий элемент, наследуемый более производными классами; переопределенный элемент все еще переопределен|  
  
 <sup>1</sup> *вызывающая последовательность* состоит из типа элемента ( `Function` ,, `Sub` `Operator` или `Property` ), имени, списка параметров и типа возвращаемого значения. Процедуру нельзя переопределить с помощью свойства или наоборот. Нельзя переопределить один тип процедуры ( `Function` , `Sub` или `Operator` ) другим видом.  
  
 <sup>2</sup> если параметр или не указан `Shadows` `Overrides` , компилятор выдает предупреждающее сообщение, помогающее определить, какой тип переопределения вы хотите использовать. При пропуске предупреждения используется механизм теневого копирования.  
  
 <sup>3</sup> если элемент с тенью недоступен в последующем производном классе, то затенение не наследуется. Например, если объявить элемент с тенью как `Private` , класс, производный от производного класса, наследует исходный элемент, а не элемент с тенью.  
  
## <a name="guidelines"></a>Рекомендации  
 Обычно переопределение используется в следующих случаях:  
  
- Вы определяете классы, производные от полиморфизма.  
  
- Необходимо обеспечить безопасность, чтобы компилятор принудительно применяет идентичный тип элемента и вызывающую последовательность.  
  
 Затенение обычно используется в следующих случаях:  
  
- Предполагается, что базовый класс может быть изменен и определен элемент с тем же именем, что и у вашего.  
  
- Требуется свобода изменения типа элемента или последовательности вызовов.  
  
## <a name="see-also"></a>См. также раздел

- [References to Declared Elements](references-to-declared-elements.md)
- [Сокрытие в Visual Basic](shadowing.md)
- [Практическое руководство. Сокрытие переменной с тем же именем, что и ваша переменная](how-to-hide-a-variable-with-the-same-name-as-your-variable.md)
- [Практическое руководство. Сокрытие наследуемой переменной](how-to-hide-an-inherited-variable.md)
- [Практическое руководство. Доступ к переменной, скрытой производным классом](how-to-access-a-variable-hidden-by-a-derived-class.md)
- [Shadows](../../../language-reference/modifiers/shadows.md)
- [Переопределения](../../../language-reference/modifiers/overrides.md)
