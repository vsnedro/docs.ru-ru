---
title: Основы наследования
ms.date: 07/20/2015
helpviewer_keywords:
- derived classes [Visual Basic], inheritance
- MyClass keyword [Visual Basic], using
- MyBase keyword [Visual Basic], using
- Inherits statement [Visual Basic], inheritance
- overriding, Overridable keyword
- MustInherit keyword [Visual Basic], using
- Overrides keyword [Visual Basic], using
- inheritance
- MustInherit classes [Visual Basic]
- MustOverride keyword [Visual Basic], using
- classes [Visual Basic], derived
- NotInheritable keyword [Visual Basic], using
- base classes [Visual Basic], extending properties and methods [Visual Basic]
- NotOverridable keyword [Visual Basic], using
- base classes [Visual Basic], inheritance
- abstract classes [Visual Basic], inheritance
- overriding, Overrides keyword
ms.assetid: dfc8deba-f5b3-4d1d-a937-7cb826446fc5
ms.openlocfilehash: 3bf1847f618a642d26df4aa1c5247a4ba2bd3b23
ms.sourcegitcommit: f8c270376ed905f6a8896ce0fe25b4f4b38ff498
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/04/2020
ms.locfileid: "84411783"
---
# <a name="inheritance-basics-visual-basic"></a>Основы наследования (Visual Basic)

`Inherits`Оператор используется для объявления нового класса, называемого *производным классом*, на основе существующего класса, называемого *базовым классом*. Производные классы наследуют и могут расширять, свойства, методы, события, поля и константы, определенные в базовом классе. В следующем разделе описаны некоторые правила наследования, а также модификаторы, которые можно использовать для изменения способа наследования или наследования классов.

- По умолчанию все классы наследуются, если только они не помечены `NotInheritable` ключевым словом. Классы могут наследовать от других классов в проекте или из классов в других сборках, на которые ссылается проект.

- В отличие от языков, допускающих множественное наследование, Visual Basic допускает только одно наследование в классах; то есть производные классы могут иметь только один базовый класс. Хотя множественное наследование не разрешено в классах, классы могут реализовывать несколько интерфейсов, что может эффективно выполнять те же самые концы.

- Чтобы предотвратить предоставление ограниченных элементов в базовом классе, тип доступа производного класса должен быть равным или более ограничивающим, чем его базовый класс. Например, `Public` класс не может наследовать `Friend` `Private` класс или, а `Friend` класс не может наследовать `Private` класс.

## <a name="inheritance-modifiers"></a>Модификаторы наследования

Visual Basic вводит следующие операторы и модификаторы уровня класса для поддержки наследования:

- `Inherits`оператор — указывает базовый класс.

- `NotInheritable`модификатор — не позволяет программистам использовать класс в качестве базового класса.

- `MustInherit`модификатор — указывает, что класс предназначен для использования только в качестве базового класса. Экземпляры `MustInherit` классов нельзя создавать напрямую; они могут быть созданы только как экземпляры базового класса производного класса. (Другие языки программирования, такие как C++ и C#, используют термин *абстрактный класс* для описания такого класса.)

## <a name="overriding-properties-and-methods-in-derived-classes"></a>Переопределение свойств и методов в производных классах

По умолчанию производный класс наследует свойства и методы от своего базового класса. Если унаследованное свойство или метод должны вести себя по-разному в производном классе, его можно *переопределить*. То есть можно определить новую реализацию метода в производном классе. Следующие модификаторы используются для управления переопределением свойств и методов.

- `Overridable`— Позволяет переопределять свойство или метод в классе в производном классе.

- `Overrides`— Переопределяет `Overridable` свойство или метод, определенный в базовом классе.

- `NotOverridable`— Предотвращает переопределение свойства или метода в наследующем классе. По умолчанию `Public` методы имеют значение `NotOverridable` .

- `MustOverride`— Требует, чтобы производный класс переопределял свойство или метод. При `MustOverride` использовании ключевого слова определение метода состоит только из `Sub` `Function` оператора, или `Property` . Другие инструкции не допускаются, а в частности нет `End Sub` оператора или `End Function` . `MustOverride`методы должны быть объявлены в `MustInherit` классах.

Предположим, необходимо определить классы для работы с Payroll. Можно определить универсальный `Payroll` класс, содержащий `RunPayroll` метод, который вычисляет зарплату для типичной недели. Затем можно использовать `Payroll` в качестве базового класса для более специализированного `BonusPayroll` класса, который можно использовать при распределении премий сотрудников.

`BonusPayroll`Класс может наследовать и переопределять метод, `PayEmployee` определенный в базовом `Payroll` классе.

В следующем примере определяется базовый класс `Payroll,` и производный класс, `BonusPayroll` который переопределяет унаследованный метод `PayEmployee` . Процедура, `RunPayroll` , создает и передает `Payroll` объект и `BonusPayroll` объект в функцию, `Pay` которая выполняет `PayEmployee` метод обоих объектов.

[!code-vb[VbVbalrOOP#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#28)]

## <a name="the-mybase-keyword"></a>Ключевое слово MyBase

`MyBase`Ключевое слово ведет себя как объектная переменная, которая ссылается на базовый класс текущего экземпляра класса. `MyBase`часто используется для доступа к членам базового класса, которые переопределяются или переобъявляются в производном классе. В частности, `MyBase.New` используется для явного вызова конструктора базового класса из конструктора производного класса.

Например, предположим, что вы разрабатываете производный класс, переопределяющий метод, унаследованный от базового класса. Переопределенный метод может вызвать метод в базовом классе и изменить возвращаемое значение, как показано в следующем фрагменте кода:

[!code-vb[VbVbalrOOP#109](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrOOP/VB/OOP.vb#109)]

В следующем списке описаны ограничения на использование `MyBase` :

- `MyBase`ссылается на непосредственный базовый класс и его унаследованные члены. Его нельзя использовать для доступа к `Private` членам в классе.

- `MyBase`— Это ключевое слово, а не реальный объект. `MyBase`нельзя присвоить значение переменной, передать ее процедурам или использовать в `Is` сравнении.

- Метод, который `MyBase` не обязательно должен быть определен в непосредственном базовом классе; он может быть определен в косвенно наследуемом базовом классе. Чтобы обеспечить `MyBase` правильную компиляцию ссылки, в некоторых базовых классах должен содержаться метод, соответствующий имени и типам параметров, которые отображаются в вызове.

- Нельзя использовать `MyBase` для вызова `MustOverride` методов базового класса.

- `MyBase`не может использоваться для уточнения самого себя. Поэтому следующий код является недопустимым:

  `MyBase.MyBase.BtnOK_Click()`

- `MyBase`не может использоваться в модулях.

- `MyBase`не может использоваться для доступа к членам базового класса, помеченным как, `Friend` Если базовый класс находится в другой сборке.

Дополнительные сведения и другой пример см. в разделе [как получить доступ к переменной, скрытой производным классом](../declared-elements/how-to-access-a-variable-hidden-by-a-derived-class.md).

## <a name="the-myclass-keyword"></a>Ключевое слово MyClass

`MyClass`Ключевое слово ведет себя как объектная переменная, которая ссылается на текущий экземпляр класса как изначально реализованный. `MyClass`Похоже `Me` на, но каждый вызов метода и свойства в обрабатывается `MyClass` так, как если бы метод или свойство были [NotOverridable](../../../language-reference/modifiers/notoverridable.md). Таким образом, переопределение в производном классе не влияет на метод или свойство.

- `MyClass`— Это ключевое слово, а не реальный объект. `MyClass`нельзя присвоить значение переменной, передать ее процедурам или использовать в `Is` сравнении.

- `MyClass`ссылается на содержащий класс и его унаследованные члены.

- `MyClass`может использоваться в качестве квалификатора для `Shared` членов.

- `MyClass`не может использоваться внутри `Shared` метода, но может использоваться внутри метода экземпляра для доступа к общему члену класса.

- `MyClass`не может использоваться в стандартных модулях.

- `MyClass`можно использовать для определения метода, который определен в базовом классе и не имеет реализации метода, предоставленного в этом классе. Такая ссылка имеет то же значение, что и `MyBase.` *метод*.

В следующем примере сравниваются `Me` и `MyClass` .

```vb
Class baseClass
    Public Overridable Sub testMethod()
        MsgBox("Base class string")
    End Sub
    Public Sub useMe()
        ' The following call uses the calling class's method, even if
        ' that method is an override.
        Me.testMethod()
    End Sub
    Public Sub useMyClass()
        ' The following call uses this instance's method and not any
        ' override.
        MyClass.testMethod()
    End Sub
End Class
Class derivedClass : Inherits baseClass
    Public Overrides Sub testMethod()
        MsgBox("Derived class string")
    End Sub
End Class
Class testClasses
    Sub startHere()
        Dim testObj As derivedClass = New derivedClass()
        ' The following call displays "Derived class string".
        testObj.useMe()
        ' The following call displays "Base class string".
        testObj.useMyClass()
    End Sub
End Class
```

Несмотря на `derivedClass` то `testMethod` что переопределения, `MyClass` ключевое слово в `useMyClass` сводят последствия переопределения, и компилятор разрешает вызов к версии базового класса `testMethod` .

## <a name="see-also"></a>См. также раздел

- [Inherits Statement](../../../language-reference/statements/inherits-statement.md)
- [Me, My, MyBase и MyClass](../../program-structure/me-my-mybase-and-myclass.md)
